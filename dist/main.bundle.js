/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(15)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_autoplay__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_autoplay___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__mixins_autoplay__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__slide_vue__ = __webpack_require__(5);
//
//
//
//
//
//
//
//



const noop = () => {};
/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'carousel3d',
    components: {
        Slide: __WEBPACK_IMPORTED_MODULE_1__slide_vue__["default"]
    },
    props: {
        count: {
            type: [Number, String],
            default: 0
        },
        perspective: {
            type: [Number, String],
            default: 35
        },
        display: {
            type: [Number, String],
            default: 5
        },
        loop: {
            type: Boolean,
            default: true
        },
        animationSpeed: {
            type: [Number, String],
            default: 500
        },
        dir: {
            type: String,
            default: 'rtl'
        },
        width: {
            type: [Number, String],
            default: 360
        },
        height: {
            type: [Number, String],
            default: 270
        },
        border: {
            type: [Number, String],
            default: 1
        },
        space: {
            type: [Number, String],
            default: 'auto'
        },
        startIndex: {
            type: [Number, String],
            default: 0
        },
        clickable: {
            type: Boolean,
            default: true
        },
        disable3d: {
            type: Boolean,
            default: false
        },
        minSwipeDistance: {
            type: Number,
            default: 10
        },
        inverseScaling: {
            type: [Number, String],
            default: 500
        },
        controlsVisible: {
            type: Boolean,
            default: false
        },
        controlsPrevHtml: {
            type: String,
            default: '&lsaquo;'
        },
        controlsNextHtml: {
            type: String,
            default: '&rsaquo;'
        },
        controlsWidth: {
            type: [String, Number],
            default: 50
        },
        controlsHeight: {
            type: [String, Number],
            default: 50
        },
        onLastSlide: {
            type: Function,
            default: noop
        },
        onSlideChange: {
            type: Function,
            default: noop
        },
        bias: {
            type: String,
            default: 'left'
        }
    },
    data() {
        return {
            viewport: 0,
            currentIndex: 0,
            total: 0,
            lock: false,
            dragOffset: 0,
            dragStartX: 0,
            mousedown: false,
            zIndex: 998
        };
    },
    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins_autoplay___default.a],
    watch: {
        count() {
            this.computeData();
        }
    },
    computed: {
        isLastSlide() {
            return this.currentIndex === this.total - 1;
        },
        isFirstSlide() {
            return this.currentIndex === 0;
        },
        isNextPossible() {
            return !(!this.loop && this.isLastSlide);
        },
        isPrevPossible() {
            return !(!this.loop && this.isFirstSlide);
        },
        slideWidth() {
            const vw = this.viewport;
            const sw = parseInt(this.width) + parseInt(this.border, 10) * 2;
            return vw < sw ? vw : sw;
        },
        slideHeight() {
            const sw = parseInt(this.width, 10) + parseInt(this.border, 10) * 2;
            const sh = parseInt(parseInt(this.height) + this.border * 2, 10);
            const ar = this.calculateAspectRatio(sw, sh);
            return this.slideWidth / ar;
        },
        visible() {
            const v = this.display > this.total ? this.total : this.display;
            return v;
        },
        hasHiddenSlides() {
            return this.total > this.visible;
        },
        leftIndices() {
            let n = (this.visible - 1) / 2;
            n = this.bias.toLowerCase() === 'left' ? Math.ceil(n) : Math.floor(n);
            const indices = [];
            for (let m = 1; m <= n; m++) {
                indices.push(this.dir === 'ltr' ? (this.currentIndex + m) % this.total : (this.currentIndex - m) % this.total);
            }
            return indices;
        },
        rightIndices() {
            let n = (this.visible - 1) / 2;
            n = this.bias.toLowerCase() === 'right' ? Math.ceil(n) : Math.floor(n);
            const indices = [];
            for (let m = 1; m <= n; m++) {
                indices.push(this.dir === 'ltr' ? (this.currentIndex - m) % this.total : (this.currentIndex + m) % this.total);
            }
            return indices;
        },
        leftOutIndex() {
            let n = (this.visible - 1) / 2;
            n = this.bias.toLowerCase() === 'left' ? Math.ceil(n) : Math.floor(n);
            n++;
            if (this.dir === 'ltr') {
                return this.total - this.currentIndex - n <= 0 ? -parseInt(this.total - this.currentIndex - n) : this.currentIndex + n;
            } else {
                return this.currentIndex - n;
            }
        },
        rightOutIndex() {
            let n = (this.visible - 1) / 2;
            n = this.bias.toLowerCase() === 'right' ? Math.ceil(n) : Math.floor(n);
            n++;
            if (this.dir === 'ltr') {
                return this.currentIndex - n;
            } else {
                return this.total - this.currentIndex - n <= 0 ? -parseInt(this.total - this.currentIndex - n, 10) : this.currentIndex + n;
            }
        }
    },
    methods: {
        /**
         * Go to next slide
         */
        goNext() {
            if (this.isNextPossible) {
                this.isLastSlide ? this.goSlide(0) : this.goSlide(this.currentIndex + 1);
            }
        },
        /**
         * Go to previous slide
         */
        goPrev() {
            if (this.isPrevPossible) {
                this.isFirstSlide ? this.goSlide(this.total - 1) : this.goSlide(this.currentIndex - 1);
            }
        },
        /**
         * Go to slide
         * @param  {String} index of slide where to go
         */
        goSlide(index) {
            this.currentIndex = index < 0 || index > this.total - 1 ? 0 : index;
            this.lock = true;
            if (this.isLastSlide) {
                if (this.onLastSlide !== noop) {
                    console.warn('onLastSlide deprecated, please use @last-slide');
                }
                this.onLastSlide(this.currentIndex);
                this.$emit('last-slide', this.currentIndex);
            }
            this.$emit('before-slide-change', this.currentIndex);
            setTimeout(() => this.animationEnd(), this.animationSpeed);
        },
        /**
         * Go to slide far slide
         */
        goFar(index) {
            let diff = index === this.total - 1 && this.isFirstSlide ? -1 : index - this.currentIndex;
            if (this.isLastSlide && index === 0) {
                diff = 1;
            }
            const diff2 = diff < 0 ? -diff : diff;
            let timeBuff = 0;
            let i = 0;
            while (i < diff2) {
                i += 1;
                const timeout = diff2 === 1 ? 0 : timeBuff;
                setTimeout(() => diff < 0 ? this.goPrev(diff2) : this.goNext(diff2), timeout);
                timeBuff += this.animationSpeed / diff2;
            }
        },
        /**
         * Trigger actions when animation ends
         */
        animationEnd() {
            this.lock = false;
            if (this.onSlideChange !== noop) {
                console.warn('onSlideChange deprecated, please use @after-slide-change');
            }
            this.onSlideChange(this.currentIndex);
            this.$emit('after-slide-change', this.currentIndex);
        },
        /**
         * Trigger actions when mouse is released
         * @param  {Object} e The event object
         */
        handleMouseup() {
            this.mousedown = false;
            this.dragOffset = 0;
        },
        /**
         * Trigger actions when mouse is pressed
         * @param  {Object} e The event object
         */
        handleMousedown(e) {
            if (!e.touches) {
                e.preventDefault();
            }
            this.mousedown = true;
            this.dragStartX = 'ontouchstart' in window ? e.touches[0].clientX : e.clientX;
        },
        /**
         * Trigger actions when mouse is pressed and then moved (mouse drag)
         * @param  {Object} e The event object
         */
        handleMousemove(e) {
            if (!this.mousedown) {
                return;
            }
            const eventPosX = 'ontouchstart' in window ? e.touches[0].clientX : e.clientX;
            const deltaX = this.dragStartX - eventPosX;
            this.dragOffset = deltaX;
            if (this.dragOffset > this.minSwipeDistance) {
                this.handleMouseup();
                this.goNext();
            } else if (this.dragOffset < -this.minSwipeDistance) {
                this.handleMouseup();
                this.goPrev();
            }
        },
        /**
         * A mutation observer is used to detect changes to the containing node
         * in order to keep the magnet container in sync with the height its reference node.
         */
        attachMutationObserver() {
            const MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
            if (MutationObserver) {
                const config = {
                    attributes: true,
                    childList: true,
                    characterData: true
                };
                this.mutationObserver = new MutationObserver(() => {
                    this.$nextTick(() => {
                        this.computeData();
                    });
                });
                if (this.$el) {
                    this.mutationObserver.observe(this.$el, config);
                }
            }
        },
        /**
         * Stop listening to mutation changes
         */
        detachMutationObserver() {
            if (this.mutationObserver) {
                this.mutationObserver.disconnect();
            }
        },
        /**
         * Get the number of slides
         * @return {Number} Number of slides
         */
        getSlideCount() {
            if (this.$slots.default !== undefined) {
                return this.$slots.default.filter(value => {
                    return value.tag !== void 0;
                }).length;
            }
            return 0;
        },
        /**
         * Calculate slide with and keep defined aspect ratio
         * @return {Number} Aspect ratio number
         */
        calculateAspectRatio(width, height) {
            return Math.min(width / height);
        },
        /**
         * Re-compute the number of slides and current slide
         */
        computeData() {
            this.total = this.getSlideCount();
            this.currentIndex = parseInt(this.startIndex) > this.total - 1 ? this.total - 1 : parseInt(this.startIndex);
            this.viewport = this.$el.clientWidth;
        },
        setSize() {
            this.$el.style.cssText += 'height:' + this.slideHeight + 'px;';
            this.$el.childNodes[0].style.cssText += 'width:' + this.slideWidth + 'px;' + ' height:' + this.slideHeight + 'px;';
        }
    },
    mounted() {
        this.computeData();
        this.attachMutationObserver();
        if (!this.$isServer) {
            window.addEventListener('resize', this.setSize);
            if ('ontouchstart' in window) {
                this.$el.addEventListener('touchstart', this.handleMousedown);
                this.$el.addEventListener('touchend', this.handleMouseup);
                this.$el.addEventListener('touchmove', this.handleMousemove);
            } else {
                this.$el.addEventListener('mousedown', this.handleMousedown);
                this.$el.addEventListener('mouseup', this.handleMouseup);
                this.$el.addEventListener('mousemove', this.handleMousemove);
            }
        }
    },
    beforeDestroy() {
        if (!this.$isServer) {
            this.detachMutationObserver();
            if ('ontouchstart' in window) {
                this.$el.removeEventListener('touchmove', this.handleMousemove);
            } else {
                this.$el.removeEventListener('mousemove', this.handleMousemove);
            }
            window.removeEventListener('resize', this.setSize);
        }
    }
});

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_slide_vue__ = __webpack_require__(6);
/* empty harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bcaa0af4_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_slide_vue__ = __webpack_require__(19);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(17)
}
var normalizeComponent = __webpack_require__(3)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_slide_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_bcaa0af4_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_slide_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "demo\\slide.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-bcaa0af4", Component.options)
  } else {
    hotAPI.reload("data-v-bcaa0af4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'slide',
    props: {
        index: {
            type: Number
        }
    },
    data() {
        return {
            parent: this.$parent,
            styles: {},
            zIndex: 999
        };
    },
    computed: {
        isCurrent() {
            return this.index === this.parent.currentIndex;
        },
        slideStyle() {
            let styles = {};
            if (!this.isCurrent) {
                const rIndex = this.getSideIndex(this.parent.rightIndices);
                const lIndex = this.getSideIndex(this.parent.leftIndices);
                if (rIndex >= 0 || lIndex >= 0) {
                    styles = rIndex >= 0 ? this.calculatePosition(rIndex, true, this.zIndex) : this.calculatePosition(lIndex, false, this.zIndex);
                    styles.opacity = 1;
                    styles.visibility = 'visible';
                }
                if (this.parent.hasHiddenSlides) {
                    if (this.matchIndex(this.parent.leftOutIndex)) {
                        styles = this.calculatePosition(this.parent.leftIndices.length - 1, false, this.zIndex);
                    } else if (this.matchIndex(this.parent.rightOutIndex)) {
                        styles = this.calculatePosition(this.parent.rightIndices.length - 1, true, this.zIndex);
                    }
                }
            }
            return Object.assign(styles, {
                'border-width': this.parent.border + 'px',
                'width': this.parent.slideWidth + 'px',
                'height': this.parent.slideHeight + 'px',
                'transition': ' transform ' + this.parent.animationSpeed + 'ms, ' + '               opacity ' + this.parent.animationSpeed + 'ms, ' + '               visibility ' + this.parent.animationSpeed + 'ms'
            });
        }
    },
    methods: {
        getSideIndex(array) {
            let index = -1;
            array.forEach((pos, i) => {
                if (this.matchIndex(pos)) {
                    index = i;
                }
            });
            return index;
        },
        matchIndex(index) {
            return index >= 0 ? this.index === index : this.parent.total + index === this.index;
        },
        calculatePosition(i, positive, zIndex) {
            const z = !this.parent.disable3d ? parseInt(this.parent.inverseScaling) + (i + 1) * 100 : 0;
            const y = !this.parent.disable3d ? parseInt(this.parent.perspective) : 0;
            const leftRemain = this.parent.space === 'auto' ? parseInt((i + 1) * (this.parent.width / 1.5), 10) : parseInt((i + 1) * this.parent.space, 10);
            const transform = positive ? 'translateX(' + leftRemain + 'px) translateZ(-' + z + 'px) ' + 'rotateY(-' + y + 'deg)' : 'translateX(-' + leftRemain + 'px) translateZ(-' + z + 'px) ' + 'rotateY(' + y + 'deg)';
            const top = this.parent.space === 'auto' ? 0 : parseInt((i + 1) * this.parent.space);
            return {
                transform: transform,
                top: top
                // zIndex: zIndex - (Math.abs(i) + 1)
            };
        },
        goTo() {
            if (this.parent.clickable === true) {
                this.parent.goFar(this.index);
            }
        }
    }
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(8);

var _vue2 = _interopRequireDefault(_vue);

var _carousel = __webpack_require__(12);

var _carousel2 = _interopRequireDefault(_carousel);

var _slide = __webpack_require__(5);

var _slide2 = _interopRequireDefault(_slide);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import SlideShow from './test.vue';
new _vue2.default({
  el: '.app',
  components: { carousel3d: _carousel2.default, slide: _slide2.default },
  // components: {SlideShow},
  // data: {
  //   invTime: 2000,
  //   autoPlay: false,
  //   slides: [
  //     {
  //       src: require('./images/1.jpg'),
  //       title: 'xxx1',
  //       href: 'detail/analysis',
  //       id: 0
  //     },
  //     {
  //       src: require('./images/2.jpg'),
  //       title: 'xxx2',
  //       href: 'detail/count',
  //       id: 1
  //     },
  //     {
  //       src: require('./images/3.jpg'),
  //       title: 'xxx3',
  //       href: 'http://xxx.xxx.com',
  //       id: 2
  //     },
  //     {
  //       src: require('./images/4.jpg'),
  //       title: 'xxx4',
  //       href: 'detail/forecast',
  //       id: 3
  //     },
  //     {
  //       src: require('./images/5.jpg'),
  //       title: 'xxx4',
  //       href: 'detail/forecast',
  //       id: 4
  //     }
  //   ]
  // }
  data: {
    autoplay: false,
    space: 300
  }

});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.8
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();
})(undefined, function () {
  'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // these helpers produces better vm code in JS engines due to their
  // explicitness and function inlining
  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  }

  /**
   * Get the raw type string of a value e.g. [object Object]
   */
  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert a input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if a attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether the object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });

  /**
   * Simple bind, faster than native
   */
  function bind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }
    // record original fn length
    boundFn._length = fn.length;
    return boundFn;
  }

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function no(a, b, c) {
    return false;
  };

  /**
   * Return same value
   */
  var identity = function identity(_) {
    return _;
  };

  /**
   * Generate a static keys string from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = /[^\w.$]/;
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function isServerRendering() {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = noop; // work around flow check
  var formatComponentName = noop;

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function classify(str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function warn(msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function tip(msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function formatComponentName(vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }
      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat = function repeat(str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };

    generateComponentTrace = function generateComponentTrace(vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // the current target watcher being evaluated.
  // this is globally unique because there could be only one
  // watcher being evaluated at any time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(_target) {
    if (Dep.target) {
      targetStack.push(Dep.target);
    }
    Dep.target = _target;
  }

  function popTarget() {
    Dep.target = targetStack.pop();
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.functionalContext = undefined;
    this.functionalOptions = undefined;
    this.functionalScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function createEmptyVNode(text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode, deep) {
    var componentOptions = vnode.componentOptions;
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.isCloned = true;
    if (deep) {
      if (vnode.children) {
        cloned.children = cloneVNodes(vnode.children, true);
      }
      if (componentOptions && componentOptions.children) {
        componentOptions.children = cloneVNodes(componentOptions.children, true);
      }
    }
    return cloned;
  }

  function cloneVNodes(vnodes, deep) {
    var len = vnodes.length;
    var res = new Array(len);
    for (var i = 0; i < len; i++) {
      res[i] = cloneVNode(vnodes[i], deep);
    }
    return res;
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * By default, when a reactive property is set, the new value is
   * also converted to become reactive. However when passing down props,
   * we don't want to force conversion because the value may be a nested value
   * under a frozen data structure. Converting it would defeat the optimization.
   */
  var observerState = {
    shouldConvert: true
  };

  /**
   * Observer class that are attached to each observed
   * object. Once attached, the observer converts target
   * object's property keys into getter/setters that
   * collect dependencies and dispatches updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      var augment = hasProto ? protoAugment : copyAugment;
      augment(value, arrayMethods, arrayKeys);
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src, keys) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment an target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */
        if ("development" !== 'production' && customSetter) {
          customSetter();
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      "development" !== 'production' && assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function defaultStrat(parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Validate component names
   */
  function checkComponents(options) {
    for (var key in options.components) {
      var lower = key.toLowerCase();
      if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
        warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
      }
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options, vm) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    } else {
      warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options, vm) {
    var inject = options.inject;
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
      }
    } else if ("development" !== 'production' && inject) {
      warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def = dirs[key];
        if (typeof def === 'function') {
          dirs[key] = { bind: def, update: def };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    var extendsFrom = child.extends;
    if (extendsFrom) {
      parent = mergeOptions(parent, extendsFrom, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ("development" !== 'production' && warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // handle boolean props
    if (isType(Boolean, prop.type)) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
        value = true;
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldConvert = observerState.shouldConvert;
      observerState.shouldConvert = true;
      observe(value);
      observerState.shouldConvert = prevShouldConvert;
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ("development" !== 'production' && isObject(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }
    if (!valid) {
      warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isType(type, fn) {
    if (!Array.isArray(fn)) {
      return getType(fn) === getType(type);
    }
    for (var i = 0, len = fn.length; i < len; i++) {
      if (getType(fn[i]) === getType(type)) {
        return true;
      }
    }
    /* istanbul ignore next */
    return false;
  }

  /*  */

  function handleError(err, vm, info) {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        logError(e, null, 'config.errorHandler');
      }
    }
    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }

  /*  */
  /* globals MessageChannel */

  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using both micro and macro tasks.
  // In < 2.4 we used micro tasks everywhere, but there are some scenarios where
  // micro tasks have too high a priority and fires in between supposedly
  // sequential events (e.g. #4521, #6690) or even between bubbling of the same
  // event (#6566). However, using macro tasks everywhere also has subtle problems
  // when state is changed right before repaint (e.g. #6813, out-in transitions).
  // Here we use micro task by default, but expose a way to force macro task when
  // needed (e.g. in event handlers attached by v-on).
  var microTimerFunc;
  var macroTimerFunc;
  var useMacroTask = false;

  // Determine (macro) Task defer implementation.
  // Technically setImmediate should be the ideal choice, but it's only available
  // in IE. The only polyfill that consistently queues the callback after all DOM
  // events triggered in the same loop is by using MessageChannel.
  /* istanbul ignore if */
  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    macroTimerFunc = function macroTimerFunc() {
      setImmediate(flushCallbacks);
    };
  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]')) {
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = flushCallbacks;
    macroTimerFunc = function macroTimerFunc() {
      port.postMessage(1);
    };
  } else {
    /* istanbul ignore next */
    macroTimerFunc = function macroTimerFunc() {
      setTimeout(flushCallbacks, 0);
    };
  }

  // Determine MicroTask defer implementation.
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    microTimerFunc = function microTimerFunc() {
      p.then(flushCallbacks);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else {
    // fallback to macro
    microTimerFunc = macroTimerFunc;
  }

  /**
   * Wrap a function so that if any code inside triggers state change,
   * the changes are queued using a Task instead of a MicroTask.
   */
  function withMacroTask(fn) {
    return fn._withTask || (fn._withTask = function () {
      useMacroTask = true;
      var res = fn.apply(null, arguments);
      useMacroTask = false;
      return res;
    });
  }

  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      if (useMacroTask) {
        macroTimerFunc();
      } else {
        microTimerFunc();
      }
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function mark(tag) {
        return perf.mark(tag);
      };
      measure = function measure(name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        perf.clearMeasures(name);
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function warnNonPresent(target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
        if (!has && !isAllowed) {
          warnNonPresent(target, key);
        }
        return has || !isAllowed;
      }
    };

    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          warnNonPresent(target, key);
        }
        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val)) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          cloned[i].apply(null, arguments$1);
        }
      } else {
        // return handler return value for single handlers
        return fns.apply(null, arguments);
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, vm) {
    var name, cur, old, event;
    for (name in on) {
      cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur);
        }
        add(event.name, cur, event.once, event.capture, event.passive);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor, context) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (isDef(factory.contexts)) {
      // already pending
      factory.contexts.push(context);
    } else {
      var contexts = factory.contexts = [context];
      var sync = true;

      var forceRender = function forceRender() {
        for (var i = 0, l = contexts.length; i < l; i++) {
          contexts[i].$forceUpdate();
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender();
        }
      });

      var reject = once(function (reason) {
        "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender();
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (typeof res.then === 'function') {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isDef(res.component) && typeof res.component.then === 'function') {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender();
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn, once) {
    if (once) {
      target.$once(event, fn);
    } else {
      target.$on(event, fn);
    }
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var this$1 = this;

      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var this$1 = this;

      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$off(event[i], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      if (fn) {
        // specific handler
        var cb;
        var i$1 = cbs.length;
        while (i$1--) {
          cb = cbs[i$1];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i$1, 1);
            break;
          }
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        for (var i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args);
          } catch (e) {
            handleError(e, vm, "event handler for \"" + event + "\"");
          }
        }
      }
      return vm;
    };
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    var slots = {};
    if (!children) {
      return slots;
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.functionalContext === context) && data && data.slot != null) {
        var name = child.data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }

  function resolveScopedSlots(fns, // see flow/vnode
  res) {
    res = res || {};
    for (var i = 0; i < fns.length; i++) {
      if (Array.isArray(fns[i])) {
        resolveScopedSlots(fns[i], res);
      } else {
        res[fns[i].key] = fns[i].fn;
      }
    }
    return res;
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate');
      }
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
        , vm.$options._parentElm, vm.$options._refElm);
        // no need for the ref nodes after initial patch
        // this prevents keeping a detached DOM tree in memory (#5851)
        vm.$options._parentElm = vm.$options._refElm = null;
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      activeInstance = prevActiveInstance;
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      updateComponent = function updateComponent() {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure("vue " + name + " render", startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure("vue " + name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function updateComponent() {
        vm._update(vm._render(), hydrating);
      };
    }

    vm._watcher = new Watcher(vm, updateComponent, noop);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren
    var hasChildren = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      observerState.shouldConvert = false;
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        props[key] = validateProp(key, vm.$options.props, propsData, vm);
      }
      observerState.shouldConvert = true;
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    if (listeners) {
      var oldListeners = vm.$options._parentListeners;
      vm.$options._parentListeners = listeners;
      updateComponentListeners(vm, listeners, oldListeners);
    }
    // resolve slots + force update if has children
    if (hasChildren) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    var handlers = vm.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        try {
          handlers[i].call(vm);
        } catch (e) {
          handleError(e, vm, hook + " hook");
        }
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if ("development" !== 'production' && has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options) {
    this.vm = vm;
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = function () {};
        "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      var dep = this$1.deps[i];
      if (!this$1.newDepIds.has(dep.id)) {
        dep.removeSub(this$1);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    var this$1 = this;

    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this$1.deps[i].removeSub(this$1);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    observerState.shouldConvert = isRoot;
    var loop = function loop(key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }
        defineReactive(props, key, value, function () {
          if (vm.$parent && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) {
      loop(key);
    }observerState.shouldConvert = true;
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("Method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }
      if (props && hasOwn(props, key)) {
        "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if ("development" !== 'production' && getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
    }
    if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (methods[key] == null) {
          warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
        }
        if (props && hasOwn(props, key)) {
          warn("Method \"" + key + "\" has already been defined as a prop.", vm);
        }
        if (key in vm && isReserved(key)) {
          warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
        }
      }
      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, keyOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(keyOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    {
      dataDef.set = function (newData) {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        cb.call(vm, watcher.value);
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      observerState.shouldConvert = false;
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      observerState.shouldConvert = true;
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable;
      }) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && provideKey in source._provided) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {
            warn("Injection \"" + key + "\" not found", vm);
          }
        }
      }
      return result;
    }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
    if (isDef(ret)) {
      ret._isVList = true;
    }
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        if ("development" !== 'production' && !isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      var slotNodes = this.$slots[name];
      // warn duplicate slot usage
      if (slotNodes) {
        if ("development" !== 'production' && slotNodes._rendered) {
          warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
        }
        slotNodes._rendered = true;
      }
      nodes = slotNodes || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes);
    } else {
      return nodes;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {
    var keyCodes = config.keyCodes[key] || builtInAlias;
    if (keyCodes) {
      if (Array.isArray(keyCodes)) {
        return keyCodes.indexOf(eventKeyCode) === -1;
      } else {
        return keyCodes !== eventKeyCode;
      }
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function loop(key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          if (!(key in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) {
          loop(key);
        }
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor, isOnce) {
    // render fns generated by compiler < 2.5.4 does not provide v-once
    // information to runtime so be conservative
    var isOldVersion = arguments.length < 3;
    // if a static tree is generated by v-once, it is cached on the instance;
    // otherwise it is purely static and can be cached on the shared options
    // across all instances.
    var renderFns = this.$options.staticRenderFns;
    var cached = isOldVersion || isOnce ? this._staticTrees || (this._staticTrees = []) : renderFns.cached || (renderFns.cached = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree by doing a shallow clone.
    if (tree && !isInFor) {
      return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = renderFns[index].call(this._renderProxy, null, this);
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        "development" !== 'production' && warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
  }

  /*  */

  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var options = Ctor.options;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      return resolveSlots(children, parent);
    };

    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm = Object.create(parent);
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = data.scopedSlots || emptyObject;
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode) {
          vnode.functionalScopeId = options._scopeId;
          vnode.functionalContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      vnode.functionalContext = contextVm;
      vnode.functionalOptions = options;
      if (data.slot) {
        (vnode.data || (vnode.data = {})).slot = data.slot;
      }
    }

    return vnode;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  // hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating, parentElm, refElm) {
      if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      } else if (vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // merge component management hooks onto the placeholder node
    mergeHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm, refElm) {
    var vnodeComponentOptions = vnode.componentOptions;
    var options = {
      _isComponent: true,
      parent: parent,
      propsData: vnodeComponentOptions.propsData,
      _componentTag: vnodeComponentOptions.tag,
      _parentVnode: vnode,
      _parentListeners: vnodeComponentOptions.listeners,
      _renderChildren: vnodeComponentOptions.children,
      _parentElm: parentElm || null,
      _refElm: refElm || null
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnodeComponentOptions.Ctor(options);
  }

  function mergeHooks(data) {
    if (!data.hook) {
      data.hook = {};
    }
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var fromParent = data.hook[key];
      var ours = componentVNodeHooks[key];
      data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
    }
  }

  function mergeHook$1(one, two) {
    return function (a, b, c, d) {
      one(a, b, c, d);
      two(a, b, c, d);
    };
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    if (isDef(on[event])) {
      on[event] = [data.model.callback].concat(on[event]);
    } else {
      on[event] = data.model.callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // warn against non-primitive key
    if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (isDef(vnode)) {
      if (ns) {
        applyNS(vnode, ns);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (vm._isMounted) {
        // if the parent didn't update, the slot nodes will be the ones from
        // last render. They need to be cloned to ensure "freshness" for this render.
        for (var key in vm.$slots) {
          var slot = vm.$slots[key];
          // _rendered is a flag added by renderSlot, but may not be present
          // if the slot is passed from manually written render functions
          if (slot._rendered || slot[0] && slot[0].elm) {
            vm.$slots[key] = cloneVNodes(slot, true /* deep */);
          }
        }
      }

      vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          if (vm.$options.renderError) {
            try {
              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
            } catch (e) {
              handleError(e, vm, "renderError");
              vnode = vm._vnode;
            }
          } else {
            vnode = vm._vnode;
          }
        }
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if ("development" !== 'production' && Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };
  }

  /*  */

  var uid$1 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$1++;

      var startTag, endTag;
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    opts.parent = options.parent;
    opts.propsData = options.propsData;
    opts._parentVnode = options._parentVnode;
    opts._parentListeners = options._parentListeners;
    opts._renderChildren = options._renderChildren;
    opts._componentTag = options._componentTag;
    opts._parentElm = options._parentElm;
    opts._refElm = options._refElm;
    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var extended = Ctor.extendOptions;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = dedupe(latest[key], extended[key], sealed[key]);
      }
    }
    return modified;
  }

  function dedupe(latest, extended, sealed) {
    // compare latest and sealed to ensure lifecycle hooks won't be duplicated
    // between merges
    if (Array.isArray(latest)) {
      var res = [];
      sealed = Array.isArray(sealed) ? sealed : [sealed];
      extended = Array.isArray(extended) ? extended : [extended];
      for (var i = 0; i < latest.length; i++) {
        // push original options and not sealed options to exclude duplicated options
        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
          res.push(latest[i]);
        }
      }
      return res;
    } else {
      return latest;
    }
  }

  function Vue$3(options) {
    if ("development" !== 'production' && !(this instanceof Vue$3)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue$3);
  stateMixin(Vue$3);
  eventsMixin(Vue$3);
  lifecycleMixin(Vue$3);
  renderMixin(Vue$3);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;
      {
        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
          warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
        }
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          {
            if (type === 'component' && config.isReservedTag(id)) {
              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
            }
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && cached$$1 !== current) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed() {
      var this$1 = this;

      for (var key in this$1.cache) {
        pruneCacheEntry(this$1.cache, key, this$1.keys);
      }
    },

    watch: {
      include: function include(val) {
        pruneCache(this, function (name) {
          return matches(val, name);
        });
      },
      exclude: function exclude(val) {
        pruneCache(this, function (name) {
          return !matches(val, name);
        });
      }
    },

    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
        // not included
        include && (!name || !matches(include, name)) ||
        // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue$3);

  Object.defineProperty(Vue$3.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue$3.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  Vue$3.version = '2.5.8';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function mustUseProp(tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function isXlink(name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function getXlinkProp(name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function isFalsyAttrValue(val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function isPreTag(tag) {
    return tag === 'pre';
  };

  var isReservedTag = function isReservedTag(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        "development" !== 'production' && warn('Cannot find element: ' + el);
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setAttribute(node, key, val) {
    node.setAttribute(key, val);
  }

  var nodeOps = Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setAttribute: setAttribute
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!key) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove() {
        if (--remove.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove.listeners = listeners;
      return remove;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }

    var creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }
        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if ("development" !== 'production' && data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */, parentElm, refElm);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (ref$$1.parentNode === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      if (isDef(i = vnode.functionalScopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setAttribute(vnode.elm, i, '');
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.functionalContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          } else {
            vnodeToMove = oldCh[idxInOld];
            /* istanbul ignore if */
            if ("development" !== 'production' && !vnodeToMove) {
              warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
            }
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm$1 = nodeOps.parentNode(oldElm);

          // create new node
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm$1)) {
            removeVnodes(parentElm$1, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function callInsert() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE9 || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, value);
      }
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + "," + args;
    }
  }

  /*  */

  function baseWarn(msg) {
    console.error("[Vue compiler]: " + msg);
  }

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value) {
    (el.props || (el.props = [])).push({ name: name, value: value });
  }

  function addAttr(el, name, value) {
    (el.attrs || (el.attrs = [])).push({ name: name, value: value });
  }

  function addDirective(el, name, rawName, value, arg, modifiers) {
    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
  }

  function addHandler(el, name, value, modifiers, important, warn) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if ("development" !== 'production' && warn && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = '!' + name; // mark the event as captured
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = '~' + name; // mark the event as once
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = '&' + name; // mark the event as passive
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (name === 'click') {
      if (modifiers.right) {
        name = 'contextmenu';
        delete modifiers.right;
      } else if (modifiers.middle) {
        name = 'mouseup';
      }
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = { value: value };
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: "\"" + value + "\"",
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len;
  var str;
  var chr;
  var index$1;
  var expressionPos;
  var expressionEndPos;

  function parseModel(val) {
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
    }

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      if (value$1) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally');
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler(handler, event, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }

  function add$1(event, handler, once$$1, capture, passive) {
    handler = withMacroTask(handler);
    if (once$$1) {
      handler = createOnceHandler(handler, event, capture);
    }
    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(event, handler, capture, _target) {
    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else {
        elm[key] = cur;
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
  }

  function isDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isInputChanged(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers) && modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (isDef(modifiers) && modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function setProp(el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(name, val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def) {
    if (!def) {
      return;
    }
    /* istanbul ignore else */
    if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
      var res = {};
      if (def.css !== false) {
        extend(res, autoCssTransition(def.name || 'v'));
      }
      extend(res, def);
      return res;
    } else if (typeof def === 'string') {
      return autoCssTransition(def);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function end() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function onEnd(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[animationProp + 'Delay'].split(', ');
    var animationDurations = styles[animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    if ("development" !== 'production' && explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        addTransitionClass(el, toClass);
        removeTransitionClass(el, startClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          addTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled && !userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          if (!isAndroid) {
            el.addEventListener('compositionstart', onCompositionStart);
            el.addEventListener('compositionend', onCompositionEnd);
          }
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (value === oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show
  };

  /*  */

  // Provides transition support for a single element/component.
  // supports transition mode (out-in / in-out)

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(function (c) {
        return c.tag || isAsyncPlaceholder(c);
      });
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      // warn multiple elements
      if ("development" !== 'production' && children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode;

      // warn invalid mode
      if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(function (d) {
        return d.name === 'show';
      })) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function performLeave() {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }
  };

  /*  */

  // Provides transition support for list items.
  // supports move transitions using the FLIP technique.

  // Because the vdom's children update algorithm is "unstable" - i.e.
  // it doesn't guarantee the relative positioning of removed elements,
  // we force transition-group to update its children into two passes:
  // in the first pass, we remove all nodes that need to be removed,
  // triggering their leaving transition; in the second pass, we insert/move
  // into the final desired state. This way in the second pass removed
  // nodes will remain where they should be.

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    beforeUpdate: function beforeUpdate() {
      // force removing pass
      this.__patch__(this._vnode, this.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this._vnode = this.kept;
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue$3.config.mustUseProp = mustUseProp;
  Vue$3.config.isReservedTag = isReservedTag;
  Vue$3.config.isReservedAttr = isReservedAttr;
  Vue$3.config.getTagNamespace = getTagNamespace;
  Vue$3.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue$3.options.directives, platformDirectives);
  extend(Vue$3.options.components, platformComponents);

  // install platform patch function
  Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue$3.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  Vue$3.nextTick(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue$3);
      } else if ("development" !== 'production' && isChrome) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }
    if ("development" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);

  /*  */

  var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        tokens.push(JSON.stringify(text.slice(lastIndex, index)));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      tokens.push(JSON.stringify(text.slice(lastIndex)));
    }
    return tokens.join('+');
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if ("development" !== 'production' && staticClass) {
      var expression = parseText(staticClass, options.delimiters);
      if (expression) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };

  /*  */

  function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var expression = parseText(staticStyle, options.delimiters);
        if (expression) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };

  /*  */

  var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }
  };

  /*  */

  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
  // but for Vue templates we can enforce a simple charset
  var ncname = '[a-zA-Z_][\\w\\-\\.]*';
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i;
  var comment = /^<!--/;
  var conditionalComment = /^<!\[/;

  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t'
  };
  var encodedAttr = /&(?:lt|gt|quot|amp);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd));
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(lastTag, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
          advance(textEnd);
        }

        if (textEnd < 0) {
          text = html;
          html = '';
        }

        if (options.chars && text) {
          options.chars(text);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if ("development" !== 'production' && !stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
        }
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
          advance(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if ("development" !== 'production' && (i > pos || !tagName) && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
  var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^v-bind:/;
  var modifierRE = /\.[^.]+/g;

  var decodeHTMLCached = cached(he.decode);

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      parent: parent,
      children: []
    };
  }

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg) {
      if (!warned) {
        warned = true;
        warn$2(msg);
      }
    }

    function endPre(element) {
      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      start: function start(tag, attrs, unary) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          "development" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
          // element-scope stuff
          processElement(element, options);
        }

        function checkRootConstraints(el) {
          {
            if (el.tag === 'slot' || el.tag === 'template') {
              warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
            }
            if (el.attrsMap.hasOwnProperty('v-for')) {
              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
            }
          }
        }

        // tree management
        if (!root) {
          root = element;
          checkRootConstraints(root);
        } else if (!stack.length) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            checkRootConstraints(element);
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          } else {
            warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
          }
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else if (element.slotScope) {
            // scoped slot
            currentParent.plain = false;
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          } else {
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }
        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          endPre(element);
        }
        // apply post-transforms
        for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
          postTransforms[i$1](element, options);
        }
      },

      end: function end() {
        // remove trailing whitespace
        var element = stack[stack.length - 1];
        var lastNode = element.children[element.children.length - 1];
        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
          element.children.pop();
        }
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        endPre(element);
      },

      chars: function chars(text) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.');
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.");
            }
          }
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
        if (text) {
          var expression;
          if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
            children.push({
              type: 2,
              expression: expression,
              text: text
            });
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            children.push({
              type: 3,
              text: text
            });
          }
        }
      },
      comment: function comment(text) {
        currentParent.children.push({
          type: 3,
          text: text,
          isComment: true
        });
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var l = el.attrsList.length;
    if (l) {
      var attrs = el.attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        attrs[i] = {
          name: el.attrsList[i].name,
          value: JSON.stringify(el.attrsList[i].value)
        };
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = !element.key && !element.attrsList.length;

    processRef(element);
    processSlot(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      if ("development" !== 'production' && el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.");
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var inMatch = exp.match(forAliasRE);
      if (!inMatch) {
        "development" !== 'production' && warn$2("Invalid v-for expression: " + exp);
        return;
      }
      el.for = inMatch[2].trim();
      var alias = inMatch[1].trim();
      var iteratorMatch = alias.match(forIteratorRE);
      if (iteratorMatch) {
        el.alias = iteratorMatch[1].trim();
        el.iterator1 = iteratorMatch[2].trim();
        if (iteratorMatch[3]) {
          el.iterator2 = iteratorMatch[3].trim();
        }
      } else {
        el.alias = alias;
      }
    }
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
    }
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if ("development" !== 'production' && children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
        }
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  function processSlot(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if ("development" !== 'production' && el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
      }
    } else {
      var slotScope;
      if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        /* istanbul ignore if */
        if ("development" !== 'production' && slotScope) {
          warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
        /* istanbul ignore if */
        if ("development" !== 'production' && el.attrsMap['v-for']) {
          warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", true);
        }
        el.slotScope = slotScope;
      }
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
          addAttr(el, 'slot', slotTarget);
        }
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, isProp;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name);
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isProp = false;
          if (modifiers) {
            if (modifiers.prop) {
              isProp = true;
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
            }
          }
          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value);
          } else {
            addAttr(el, name, value);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          addHandler(el, name, value, modifiers, false, warn$2);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
          }
          addDirective(el, name, rawName, value, arg, modifiers);
          if ("development" !== 'production' && name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var expression = parseText(value, delimiters);
          if (expression) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
          }
        }
        addAttr(el, name, JSON.stringify(value));
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true');
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if ("development" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
      }
      _el = _el.parent;
    }
  }

  /*  */

  /**
   * Expand input[v-model] with dyanmic type bindings into v-if-else chains
   * Turn this:
   *   <input v-model="data[type]" :type="type">
   * into this:
   *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
   *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
   *   <input v-else :type="type" v-model="data[type]">
   */

  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
        var typeBinding = getBindingAttr(el, 'type');
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  function addRawAttr(el, name, value) {
    el.attrsMap[name] = value;
    el.attrsList.push({ name: name, value: value });
  }

  var model$2 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [klass$1, style$1, model$2];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")");
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")");
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };

  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

  // keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function genGuard(condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative, warn) {
    var res = isNative ? 'nativeOn:{' : 'on:{';
    for (var name in events) {
      res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
    }
    return res.slice(0, -1) + '}';
  }

  function genHandler(name, handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(name, handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);

    if (!handler.modifiers) {
      return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var code = keyCodes[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(code) + "," + "$event.key)";
  }

  /*  */

  function on(el, dir) {
    if ("development" !== 'production' && dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop
  };

  /*  */

  var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data = el.plain ? undefined : genData$2(el, state);

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state, once$$1) {
    el.staticProcessed = true;
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    return "_m(" + (state.staticRenderFns.length - 1) + "," + (el.staticInFor ? 'true' : 'false') + "," + (once$$1 ? 'true' : 'false') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        "development" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state, true);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if ("development" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:{" + genProps(el.attrs) + "},";
    }
    // DOM props
    if (el.props) {
      data += "domProps:{" + genProps(el.props) + "},";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false, state.warn) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true, state.warn) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if ("development" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
      state.warn('Inline-template components must have exactly one child element.');
    }
    if (ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(slots, state) {
    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state);
    }).join(',') + "])";
  }

  function genScopedSlot(key, el, state) {
    if (el.for && !el.forProcessed) {
      return genForScopedSlot(key, el, state);
    }
    var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
    return "{key:" + key + ",fn:" + fn + "}";
  }

  function genForScopedSlot(key, el, state) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
    el.forProcessed = true; // avoid recursion
    return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        return (altGenElement || genElement)(el$1, state);
      }
      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    }if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs && "{" + el.attrs.map(function (a) {
      return camelize(a.name) + ":" + a.value;
    }).join(',') + "}";
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var res = '';
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
    }
    return res.slice(0, -1);
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors(ast) {
    var errors = [];
    if (ast) {
      checkNode(ast, errors);
    }
    return errors;
  }

  function checkNode(node, errors) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", errors);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", errors);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", errors);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], errors);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, errors);
    }
  }

  function checkEvent(exp, text, errors) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    }
    checkExpression(exp, text, errors);
  }

  function checkFor(node, text, errors) {
    checkExpression(node.for || '', text, errors);
    checkIdentifier(node.alias, 'v-for alias', text, errors);
    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
  }

  function checkIdentifier(ident, type, text, errors) {
    if (typeof ident === 'string') {
      try {
        new Function("var " + ident + "=_");
      } catch (e) {
        errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
      }
    }
  }

  function checkExpression(exp, text, errors) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim());
      } else {
        errors.push("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n");
      }
    }
  }

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      }

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
        if (compiled.tips && compiled.tips.length) {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];
        finalOptions.warn = function (msg, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        var compiled = baseCompile(template, finalOptions);
        {
          errors.push.apply(errors, detectErrors(compiled.ast));
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    optimize(ast, options);
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue$3.prototype.$mount;
  Vue$3.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      "development" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if ("development" !== 'production' && !template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile end');
          measure("vue " + this._name + " compile", 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue$3.compile = compileToFunctions;

  return Vue$3;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(9).setImmediate))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(10);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(11)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_carousel_vue__ = __webpack_require__(4);
/* empty harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2f17c41b_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_carousel_vue__ = __webpack_require__(20);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(13)
}
var normalizeComponent = __webpack_require__(3)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-2f17c41b"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_carousel_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2f17c41b_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_bustCache_carousel_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "demo\\carousel.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2f17c41b", Component.options)
  } else {
    hotAPI.reload("data-v-2f17c41b", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(14);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("b8d5649e", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2f17c41b\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./carousel.vue", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2f17c41b\",\"scoped\":true,\"hasInlineConfig\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./carousel.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.carousel-3d-container[data-v-2f17c41b] {\n    min-height: 1px;\n    width: 100%;\n    position: relative;\n    z-index: 0;\n    overflow: hidden;\n    margin: 20px auto;\n    box-sizing: border-box;\n}\n.carousel-3d-slider[data-v-2f17c41b] {\n    position: relative;\n    margin: 0 auto;\n    transform-style: preserve-3d;\n    -webkit-perspective: 1000px;\n    -moz-perspective: 1000px;\n    perspective: 1000px;\n}\n", "", {"version":3,"sources":["C:/Users/Administrator/Documents/GitHub/vue-slide-show/demo/demo/carousel.vue?6b2f469a"],"names":[],"mappings":";AAsZA;IACA,gBAAA;IACA,YAAA;IACA,mBAAA;IACA,WAAA;IACA,iBAAA;IACA,kBAAA;IACA,uBAAA;CACA;AACA;IACA,mBAAA;IACA,eAAA;IACA,6BAAA;IACA,4BAAA;IACA,yBAAA;IACA,oBAAA;CACA","file":"carousel.vue","sourcesContent":["<template>\r\n    <div class=\"carousel-3d-container\" :style=\"{height: this.slideHeight + 'px'}\">\r\n        <div class=\"carousel-3d-slider\" :style=\"{width: this.slideWidth + 'px', height: this.slideHeight + 'px'}\">\r\n            <slot></slot>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import autoplay from './mixins/autoplay'\r\n    import Slide from './slide.vue'\r\n    const noop = () => {\r\n    }\r\n    export default {\r\n        name: 'carousel3d',\r\n        components: {\r\n            Slide\r\n        },\r\n        props: {\r\n            count: {\r\n                type: [Number, String],\r\n                default: 0\r\n            },\r\n            perspective: {\r\n                type: [Number, String],\r\n                default: 35\r\n            },\r\n            display: {\r\n                type: [Number, String],\r\n                default: 5\r\n            },\r\n            loop: {\r\n                type: Boolean,\r\n                default: true\r\n            },\r\n            animationSpeed: {\r\n                type: [Number, String],\r\n                default: 500\r\n            },\r\n            dir: {\r\n                type: String,\r\n                default: 'rtl'\r\n            },\r\n            width: {\r\n                type: [Number, String],\r\n                default: 360\r\n            },\r\n            height: {\r\n                type: [Number, String],\r\n                default: 270\r\n            },\r\n            border: {\r\n                type: [Number, String],\r\n                default: 1\r\n            },\r\n            space: {\r\n                type: [Number, String],\r\n                default: 'auto'\r\n            },\r\n            startIndex: {\r\n                type: [Number, String],\r\n                default: 0\r\n            },\r\n            clickable: {\r\n                type: Boolean,\r\n                default: true\r\n            },\r\n            disable3d: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n            minSwipeDistance: {\r\n                type: Number,\r\n                default: 10\r\n            },\r\n            inverseScaling: {\r\n                type: [Number, String],\r\n                default: 500\r\n            },\r\n            controlsVisible: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n            controlsPrevHtml: {\r\n                type: String,\r\n                default: '&lsaquo;'\r\n            },\r\n            controlsNextHtml: {\r\n                type: String,\r\n                default: '&rsaquo;'\r\n            },\r\n            controlsWidth: {\r\n                type: [String, Number],\r\n                default: 50\r\n            },\r\n            controlsHeight: {\r\n                type: [String, Number],\r\n                default: 50\r\n            },\r\n            onLastSlide: {\r\n                type: Function,\r\n                default: noop\r\n            },\r\n            onSlideChange: {\r\n                type: Function,\r\n                default: noop\r\n            },\r\n            bias: {\r\n                type: String,\r\n                default: 'left'\r\n            }\r\n        },\r\n        data () {\r\n            return {\r\n                viewport: 0,\r\n                currentIndex: 0,\r\n                total: 0,\r\n                lock: false,\r\n                dragOffset: 0,\r\n                dragStartX: 0,\r\n                mousedown: false,\r\n                zIndex: 998\r\n            }\r\n        },\r\n        mixins: [\r\n            autoplay\r\n        ],\r\n        watch: {\r\n            count () {\r\n                this.computeData()\r\n            }\r\n        },\r\n        computed: {\r\n            isLastSlide () {\r\n                return this.currentIndex === this.total - 1\r\n            },\r\n            isFirstSlide () {\r\n                return this.currentIndex === 0\r\n            },\r\n            isNextPossible () {\r\n                return !(!this.loop && this.isLastSlide)\r\n            },\r\n            isPrevPossible () {\r\n                return !(!this.loop && this.isFirstSlide)\r\n            },\r\n            slideWidth () {\r\n                const vw = this.viewport\r\n                const sw = parseInt(this.width) + (parseInt(this.border, 10) * 2)\r\n                return vw < sw ? vw : sw\r\n            },\r\n            slideHeight () {\r\n                const sw = parseInt(this.width, 10) + (parseInt(this.border, 10) * 2)\r\n                const sh = parseInt(parseInt(this.height) + (this.border * 2), 10)\r\n                const ar = this.calculateAspectRatio(sw, sh)\r\n                return this.slideWidth / ar\r\n            },\r\n            visible () {\r\n                const v = (this.display > this.total) ? this.total : this.display\r\n                return v\r\n            },\r\n            hasHiddenSlides () {\r\n                return this.total > this.visible\r\n            },\r\n            leftIndices () {\r\n                let n = (this.visible - 1) / 2\r\n                n = (this.bias.toLowerCase() === 'left' ? Math.ceil(n) : Math.floor(n))\r\n                const indices = []\r\n                for (let m = 1; m <= n; m++) {\r\n                    indices.push((this.dir === 'ltr')\r\n                        ? (this.currentIndex + m) % (this.total)\r\n                        : (this.currentIndex - m) % (this.total))\r\n                }\r\n                return indices\r\n            },\r\n            rightIndices () {\r\n                let n = (this.visible - 1) / 2\r\n                n = (this.bias.toLowerCase() === 'right' ? Math.ceil(n) : Math.floor(n))\r\n                const indices = []\r\n                for (let m = 1; m <= n; m++) {\r\n                    indices.push((this.dir === 'ltr')\r\n                        ? (this.currentIndex - m) % (this.total)\r\n                        : (this.currentIndex + m) % (this.total))\r\n                }\r\n                return indices\r\n            },\r\n            leftOutIndex () {\r\n                let n = (this.visible - 1) / 2\r\n                n = (this.bias.toLowerCase() === 'left' ? Math.ceil(n) : Math.floor(n))\r\n                n++\r\n                if (this.dir === 'ltr') {\r\n                    return ((this.total - this.currentIndex - n) <= 0)\r\n                        ? (-parseInt(this.total - this.currentIndex - n))\r\n                        : (this.currentIndex + n)\r\n                } else {\r\n                    return (this.currentIndex - n)\r\n                }\r\n            },\r\n            rightOutIndex () {\r\n                let n = (this.visible - 1) / 2\r\n                n = (this.bias.toLowerCase() === 'right' ? Math.ceil(n) : Math.floor(n))\r\n                n++\r\n                if (this.dir === 'ltr') {\r\n                    return (this.currentIndex - n)\r\n                } else {\r\n                    return ((this.total - this.currentIndex - n) <= 0)\r\n                        ? (-parseInt(this.total - this.currentIndex - n, 10))\r\n                        : (this.currentIndex + n)\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            /**\r\n             * Go to next slide\r\n             */\r\n            goNext () {\r\n                if (this.isNextPossible) {\r\n                    this.isLastSlide ? this.goSlide(0) : this.goSlide(this.currentIndex + 1)\r\n                }\r\n            },\r\n            /**\r\n             * Go to previous slide\r\n             */\r\n            goPrev () {\r\n                if (this.isPrevPossible) {\r\n                    this.isFirstSlide ? this.goSlide(this.total - 1) : this.goSlide(this.currentIndex - 1)\r\n                }\r\n            },\r\n            /**\r\n             * Go to slide\r\n             * @param  {String} index of slide where to go\r\n             */\r\n            goSlide (index) {\r\n                this.currentIndex = (index < 0 || index > this.total - 1) ? 0 : index\r\n                this.lock = true\r\n                if (this.isLastSlide) {\r\n                    if (this.onLastSlide !== noop) {\r\n                        console.warn('onLastSlide deprecated, please use @last-slide')\r\n                    }\r\n                    this.onLastSlide(this.currentIndex)\r\n                    this.$emit('last-slide', this.currentIndex)\r\n                }\r\n                this.$emit('before-slide-change', this.currentIndex)\r\n                setTimeout(() => this.animationEnd(), this.animationSpeed)\r\n            },\r\n            /**\r\n             * Go to slide far slide\r\n             */\r\n            goFar (index) {\r\n                let diff = (index === this.total - 1 && this.isFirstSlide) ? -1 : (index - this.currentIndex)\r\n                if (this.isLastSlide && index === 0) {\r\n                    diff = 1\r\n                }\r\n                const diff2 = (diff < 0) ? -diff : diff\r\n                let timeBuff = 0\r\n                let i = 0\r\n                while (i < diff2) {\r\n                    i += 1\r\n                    const timeout = (diff2 === 1) ? 0 : (timeBuff)\r\n                    setTimeout(() => (diff < 0) ? this.goPrev(diff2) : this.goNext(diff2), timeout)\r\n                    timeBuff += (this.animationSpeed / (diff2))\r\n                }\r\n            },\r\n            /**\r\n             * Trigger actions when animation ends\r\n             */\r\n            animationEnd () {\r\n                this.lock = false\r\n                if (this.onSlideChange !== noop) {\r\n                    console.warn('onSlideChange deprecated, please use @after-slide-change')\r\n                }\r\n                this.onSlideChange(this.currentIndex)\r\n                this.$emit('after-slide-change', this.currentIndex)\r\n            },\r\n            /**\r\n             * Trigger actions when mouse is released\r\n             * @param  {Object} e The event object\r\n             */\r\n            handleMouseup () {\r\n                this.mousedown = false\r\n                this.dragOffset = 0\r\n            },\r\n            /**\r\n             * Trigger actions when mouse is pressed\r\n             * @param  {Object} e The event object\r\n             */\r\n            handleMousedown (e) {\r\n                if (!e.touches) {\r\n                    e.preventDefault()\r\n                }\r\n                this.mousedown = true\r\n                this.dragStartX = ('ontouchstart' in window) ? e.touches[0].clientX : e.clientX\r\n            },\r\n            /**\r\n             * Trigger actions when mouse is pressed and then moved (mouse drag)\r\n             * @param  {Object} e The event object\r\n             */\r\n            handleMousemove (e) {\r\n                if (!this.mousedown) {\r\n                    return\r\n                }\r\n                const eventPosX = ('ontouchstart' in window) ? e.touches[0].clientX : e.clientX\r\n                const deltaX = (this.dragStartX - eventPosX)\r\n                this.dragOffset = deltaX\r\n                if (this.dragOffset > this.minSwipeDistance) {\r\n                    this.handleMouseup()\r\n                    this.goNext()\r\n                } else if (this.dragOffset < -this.minSwipeDistance) {\r\n                    this.handleMouseup()\r\n                    this.goPrev()\r\n                }\r\n            },\r\n            /**\r\n             * A mutation observer is used to detect changes to the containing node\r\n             * in order to keep the magnet container in sync with the height its reference node.\r\n             */\r\n            attachMutationObserver () {\r\n                const MutationObserver = window.MutationObserver ||\r\n                    window.WebKitMutationObserver ||\r\n                    window.MozMutationObserver\r\n                if (MutationObserver) {\r\n                    const config = {\r\n                        attributes: true,\r\n                        childList: true,\r\n                        characterData: true\r\n                    }\r\n                    this.mutationObserver = new MutationObserver(() => {\r\n                        this.$nextTick(() => {\r\n                            this.computeData()\r\n                        })\r\n                    })\r\n                    if (this.$el) {\r\n                        this.mutationObserver.observe(this.$el, config)\r\n                    }\r\n                }\r\n            },\r\n            /**\r\n             * Stop listening to mutation changes\r\n             */\r\n            detachMutationObserver () {\r\n                if (this.mutationObserver) {\r\n                    this.mutationObserver.disconnect()\r\n                }\r\n            },\r\n            /**\r\n             * Get the number of slides\r\n             * @return {Number} Number of slides\r\n             */\r\n            getSlideCount () {\r\n                if (this.$slots.default !== undefined) {\r\n                    return this.$slots.default.filter((value) => {\r\n                        return value.tag !== void 0\r\n                    }).length\r\n                }\r\n                return 0\r\n            },\r\n            /**\r\n             * Calculate slide with and keep defined aspect ratio\r\n             * @return {Number} Aspect ratio number\r\n             */\r\n            calculateAspectRatio (width, height) {\r\n                return Math.min(width / height)\r\n            },\r\n            /**\r\n             * Re-compute the number of slides and current slide\r\n             */\r\n            computeData () {\r\n                this.total = this.getSlideCount()\r\n                this.currentIndex = parseInt(this.startIndex) > this.total - 1 ? this.total - 1 : parseInt(this.startIndex)\r\n                this.viewport = this.$el.clientWidth\r\n            },\r\n            setSize () {\r\n                this.$el.style.cssText += 'height:' + this.slideHeight + 'px;'\r\n                this.$el.childNodes[0].style.cssText += 'width:' + this.slideWidth + 'px;' + ' height:' + this.slideHeight + 'px;'\r\n            }\r\n        },\r\n        mounted () {\r\n            this.computeData()\r\n            this.attachMutationObserver()\r\n            if (!this.$isServer) {\r\n                window.addEventListener('resize', this.setSize)\r\n                if ('ontouchstart' in window) {\r\n                    this.$el.addEventListener('touchstart', this.handleMousedown)\r\n                    this.$el.addEventListener('touchend', this.handleMouseup)\r\n                    this.$el.addEventListener('touchmove', this.handleMousemove)\r\n                } else {\r\n                    this.$el.addEventListener('mousedown', this.handleMousedown)\r\n                    this.$el.addEventListener('mouseup', this.handleMouseup)\r\n                    this.$el.addEventListener('mousemove', this.handleMousemove)\r\n                }\r\n            }\r\n        },\r\n        beforeDestroy () {\r\n            if (!this.$isServer) {\r\n                this.detachMutationObserver()\r\n                if ('ontouchstart' in window) {\r\n                    this.$el.removeEventListener('touchmove', this.handleMousemove)\r\n                } else {\r\n                    this.$el.removeEventListener('mousemove', this.handleMousemove)\r\n                }\r\n                window.removeEventListener('resize', this.setSize)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n    .carousel-3d-container {\r\n        min-height: 1px;\r\n        width: 100%;\r\n        position: relative;\r\n        z-index: 0;\r\n        overflow: hidden;\r\n        margin: 20px auto;\r\n        box-sizing: border-box;\r\n    }\r\n    .carousel-3d-slider {\r\n        position: relative;\r\n        margin: 0 auto;\r\n        transform-style: preserve-3d;\r\n        -webkit-perspective: 1000px;\r\n        -moz-perspective: 1000px;\r\n        perspective: 1000px;\r\n    }\r\n</style>"],"sourceRoot":""}]);

// exports


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var autoplay = {
    props: {
        /**
         * Flag to enable autoplay
         */
        autoplay: {
            type: Boolean,
            default: false
        },
        /**
         * Time elapsed before next slide
         */
        autoplayTimeout: {
            type: Number,
            default: 2000
        },
        /**
         * Flag to pause autoplay on hover
         */
        autoplayHoverPause: {
            type: Boolean,
            default: true
        }
    },
    data: function data() {
        return {
            autoplayInterval: null
        };
    },
    destroyed: function destroyed() {
        this.pauseAutoplay();

        if (!this.$isServer) {
            this.$el.removeEventListener('mouseenter', this.pauseAutoplay);
            this.$el.removeEventListener('mouseleave', this.startAutoplay);
        }
    },

    methods: {
        pauseAutoplay: function pauseAutoplay() {
            if (this.autoplayInterval) {
                this.autoplayInterval = clearInterval(this.autoplayInterval);
            }
        },
        startAutoplay: function startAutoplay() {
            var _this = this;

            if (this.autoplay) {
                this.autoplayInterval = setInterval(function () {
                    _this.dir === 'ltr' ? _this.goPrev() : _this.goNext();
                }, this.autoplayTimeout);
            }
        }
    },
    mounted: function mounted() {
        if (!this.$isServer && this.autoplayHoverPause) {
            this.$el.addEventListener('mouseenter', this.pauseAutoplay);
            this.$el.addEventListener('mouseleave', this.startAutoplay);
        }

        this.startAutoplay();
        console.log(this.$el);
    }
};

exports.default = autoplay;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(18);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("d032ceda", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-bcaa0af4\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./slide.vue", function() {
     var newContent = require("!!../node_modules/css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-bcaa0af4\",\"scoped\":false,\"hasInlineConfig\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./slide.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.carousel-3d-slide {\n    position: absolute;\n    opacity: 0;\n    visibility: hidden;\n    overflow: hidden;\n    top: 0;\n    border-radius: 1px;\n    border-color: #000;\n    border-color: rgba(0, 0, 0, 0.4);\n    border-style: solid;\n    background-size: cover;\n    background-color: #ccc;\n    display: block;\n    margin: 0;\n    box-sizing: border-box;\n}\n.carousel-3d-slide {\n    text-align: left;\n}\n.carousel-3d-slide img {\n    width: 100%;\n}\n.carousel-3d-slide.current {\n    opacity: 1 !important;\n    visibility: visible !important;\n    transform: none !important;\n    z-index: 999;\n}\n", "", {"version":3,"sources":["C:/Users/Administrator/Documents/GitHub/vue-slide-show/demo/demo/slide.vue?52a69348"],"names":[],"mappings":";AAkGA;IACA,mBAAA;IACA,WAAA;IACA,mBAAA;IACA,iBAAA;IACA,OAAA;IACA,mBAAA;IACA,mBAAA;IACA,iCAAA;IACA,oBAAA;IACA,uBAAA;IACA,uBAAA;IACA,eAAA;IACA,UAAA;IACA,uBAAA;CACA;AACA;IACA,iBAAA;CACA;AACA;IACA,YAAA;CACA;AACA;IACA,sBAAA;IACA,+BAAA;IACA,2BAAA;IACA,aAAA;CACA","file":"slide.vue","sourcesContent":["<template>\r\n    <div \r\n    class=\"carousel-3d-slide\" \r\n    :style=\"slideStyle\" \r\n    :class=\"{ 'current': isCurrent }\" \r\n    @click=\"goTo()\">\r\n        <slot></slot>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        name: 'slide',\r\n        props: {\r\n            index: {\r\n                type: Number\r\n            }\r\n        },\r\n        data () {\r\n            return {\r\n                parent: this.$parent,\r\n                styles: {},\r\n                zIndex: 999\r\n            }\r\n        },\r\n        computed: {\r\n            isCurrent () {\r\n                return this.index === this.parent.currentIndex\r\n            },\r\n            slideStyle () {\r\n                let styles = {}\r\n                if (!this.isCurrent) {\r\n                    const rIndex = this.getSideIndex(this.parent.rightIndices)\r\n                    const lIndex = this.getSideIndex(this.parent.leftIndices)\r\n                    if (rIndex >= 0 || lIndex >= 0) {\r\n                        styles = rIndex >= 0 ? this.calculatePosition(rIndex, true, this.zIndex) : this.calculatePosition(lIndex, false, this.zIndex)\r\n                        styles.opacity = 1\r\n                        styles.visibility = 'visible'\r\n                    }\r\n                    if (this.parent.hasHiddenSlides) {\r\n                        if (this.matchIndex(this.parent.leftOutIndex)) {\r\n                            styles = this.calculatePosition(this.parent.leftIndices.length - 1, false, this.zIndex)\r\n                        } else if (this.matchIndex(this.parent.rightOutIndex)) {\r\n                            styles = this.calculatePosition(this.parent.rightIndices.length - 1, true, this.zIndex)\r\n                        }\r\n                    }\r\n                }\r\n                return Object.assign(styles, {\r\n                    'border-width': this.parent.border + 'px',\r\n                    'width': this.parent.slideWidth + 'px',\r\n                    'height': this.parent.slideHeight + 'px',\r\n                    'transition': ' transform ' + this.parent.animationSpeed + 'ms, ' +\r\n                    '               opacity ' + this.parent.animationSpeed + 'ms, ' +\r\n                    '               visibility ' + this.parent.animationSpeed + 'ms'\r\n                })\r\n            }\r\n        },\r\n        methods: {\r\n            getSideIndex (array) {\r\n                let index = -1\r\n                array.forEach((pos, i) => {\r\n                    if (this.matchIndex(pos)) {\r\n                        index = i\r\n                    }\r\n                })\r\n                return index\r\n            },\r\n            matchIndex (index) {\r\n                return (index >= 0) ? this.index === index : (this.parent.total + index) === this.index\r\n            },\r\n            calculatePosition (i, positive, zIndex) {\r\n                const z = !this.parent.disable3d ? parseInt(this.parent.inverseScaling) + ((i + 1) * 100) : 0\r\n                const y = !this.parent.disable3d ? parseInt(this.parent.perspective) : 0\r\n                const leftRemain = (this.parent.space === 'auto')\r\n                    ? parseInt((i + 1) * (this.parent.width / 1.5), 10)\r\n                    : parseInt((i + 1) * (this.parent.space), 10)\r\n                const transform = (positive)\r\n                    ? 'translateX(' + (leftRemain) + 'px) translateZ(-' + z + 'px) ' +\r\n                    'rotateY(-' + y + 'deg)'\r\n                    : 'translateX(-' + (leftRemain) + 'px) translateZ(-' + z + 'px) ' +\r\n                    'rotateY(' + y + 'deg)'\r\n                const top = this.parent.space === 'auto' ? 0 : parseInt((i + 1) * (this.parent.space))\r\n                return {\r\n                    transform: transform,\r\n                    top: top,\r\n                    // zIndex: zIndex - (Math.abs(i) + 1)\r\n                }\r\n            },\r\n            goTo () {\r\n                if (this.parent.clickable === true) {\r\n                    this.parent.goFar(this.index)\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style>\r\n    .carousel-3d-slide {\r\n        position: absolute;\r\n        opacity: 0;\r\n        visibility: hidden;\r\n        overflow: hidden;\r\n        top: 0;\r\n        border-radius: 1px;\r\n        border-color: #000;\r\n        border-color: rgba(0, 0, 0, 0.4);\r\n        border-style: solid;\r\n        background-size: cover;\r\n        background-color: #ccc;\r\n        display: block;\r\n        margin: 0;\r\n        box-sizing: border-box;\r\n    }\r\n    .carousel-3d-slide {\r\n        text-align: left;\r\n    }\r\n    .carousel-3d-slide img {\r\n        width: 100%;\r\n    }\r\n    .carousel-3d-slide.current {\r\n        opacity: 1 !important;\r\n        visibility: visible !important;\r\n        transform: none !important;\r\n        z-index: 999;\r\n    }\r\n</style>"],"sourceRoot":""}]);

// exports


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "carousel-3d-slide",
      class: { current: _vm.isCurrent },
      style: _vm.slideStyle,
      on: {
        click: function($event) {
          _vm.goTo()
        }
      }
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-bcaa0af4", esExports)
  }
}

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "carousel-3d-container",
      style: { height: this.slideHeight + "px" }
    },
    [
      _c(
        "div",
        {
          staticClass: "carousel-3d-slider",
          style: {
            width: this.slideWidth + "px",
            height: this.slideHeight + "px"
          }
        },
        [_vm._t("default")],
        2
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2f17c41b", esExports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTBiYzAwNjJjNGNhMzViZmI1OWMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vL2RlbW8vY2Fyb3VzZWwudnVlIiwid2VicGFjazovLy8uL2RlbW8vc2xpZGUudnVlIiwid2VicGFjazovLy9kZW1vL3NsaWRlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9kZW1vL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vZGVtby92dWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9kZW1vL2Nhcm91c2VsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9kZW1vL2Nhcm91c2VsLnZ1ZT8xOTU2Iiwid2VicGFjazovLy8uL2RlbW8vY2Fyb3VzZWwudnVlP2Y2MjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kZW1vL21peGlucy9hdXRvcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9kZW1vL3NsaWRlLnZ1ZT8wMmFkIiwid2VicGFjazovLy8uL2RlbW8vc2xpZGUudnVlPzVjNGEiLCJ3ZWJwYWNrOi8vLy4vZGVtby9zbGlkZS52dWU/MTA5ZSIsIndlYnBhY2s6Ly8vLi9kZW1vL2Nhcm91c2VsLnZ1ZT83OTZmIl0sIm5hbWVzIjpbImVsIiwiY29tcG9uZW50cyIsImNhcm91c2VsM2QiLCJzbGlkZSIsImRhdGEiLCJhdXRvcGxheSIsInNwYWNlIiwiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJWdWUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiYmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJmdW5jdGlvbmFsT3B0aW9ucyIsImZ1bmN0aW9uYWxTY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJkZWVwIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJsZW4iLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlIiwiaXRlbXMiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJsb3dlciIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJpc1R5cGUiLCJCb29sZWFuIiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRDb252ZXJ0IiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsInQiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsIm1pY3JvVGltZXJGdW5jIiwibWFjcm9UaW1lckZ1bmMiLCJ1c2VNYWNyb1Rhc2siLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInRoZW4iLCJ3aXRoTWFjcm9UYXNrIiwiX3dpdGhUYXNrIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwib2xkIiwiZXZlbnQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJ0aGlzJDEiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImhhbmRsZXIiLCJjcmVhdGVXYXRjaGVyIiwia2V5T3JGbiIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImZpbHRlciIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiZXZlbnRLZXlOYW1lIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiaXNPbGRWZXJzaW9uIiwicmVuZGVyRm5zIiwic3RhdGljUmVuZGVyRm5zIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImluamVjdGlvbnMiLCJjb250ZXh0Vm0iLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsImZyb21QYXJlbnQiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCJhcHBseU5TIiwiZm9yY2UiLCJpbml0UmVuZGVyIiwicGFyZW50RGF0YSIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVmIiwicmVuZGVyRXJyb3IiLCJ1aWQkMSIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJOdW1iZXIiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwicmVmJDEiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsImRvY3VtZW50IiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsInNvbWUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZnVsbEludm9rZSIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiYWRkQXR0ciIsImFkZERpcmVjdGl2ZSIsImFyZyIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwicmlnaHQiLCJtaWRkbGUiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInZhbHVlJDEiLCJiaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib25jZUhhbmRsZXIiLCJyZW1vdmUkMiIsImFkZCQxIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJib2R5Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJleGVjIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOIiwiZyIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZWxlbWVudCIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NlZCIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NFbGVtZW50IiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInBsYWluIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwiaW5NYXRjaCIsImZvciIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJ0eXBlQmluZGluZyIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYWRkUmF3QXR0ciIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMiIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJ1cCIsImRvd24iLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJtYXliZUNvbXBvbmVudCIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJGdW5jdGlvbiIsIm1lc3NhZ2UiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsImF1dG9wbGF5VGltZW91dCIsImF1dG9wbGF5SG92ZXJQYXVzZSIsImF1dG9wbGF5SW50ZXJ2YWwiLCJwYXVzZUF1dG9wbGF5IiwiJGlzU2VydmVyIiwic3RhcnRBdXRvcGxheSIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImdvUHJldiIsImdvTmV4dCIsIm1vdW50ZWQiLCJsb2ciXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3pMRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7OztBQ3ZMdEM7QUFBQTtBQUNBO0FBQ0E7QUFDQSx3QkFBMEw7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29LO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7OztBQzdDQTs7QUFFQTtBQUNBLG9DQUFpTjtBQUNqTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYTBiYzAwNjJjNGNhMzViZmI1OWMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcblxuICAgIGlmICghZnVuY3Rpb25hbCkge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtM2QtY29udGFpbmVyXCIgOnN0eWxlPVwie2hlaWdodDogdGhpcy5zbGlkZUhlaWdodCArICdweCd9XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcm91c2VsLTNkLXNsaWRlclwiIDpzdHlsZT1cInt3aWR0aDogdGhpcy5zbGlkZVdpZHRoICsgJ3B4JywgaGVpZ2h0OiB0aGlzLnNsaWRlSGVpZ2h0ICsgJ3B4J31cIj5cclxuICAgICAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IGF1dG9wbGF5IGZyb20gJy4vbWl4aW5zL2F1dG9wbGF5J1xyXG4gICAgaW1wb3J0IFNsaWRlIGZyb20gJy4vc2xpZGUudnVlJ1xyXG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHtcclxuICAgIH1cclxuICAgIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgICAgICBuYW1lOiAnY2Fyb3VzZWwzZCcsXHJcbiAgICAgICAgY29tcG9uZW50czoge1xyXG4gICAgICAgICAgICBTbGlkZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgY291bnQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMzVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGxheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbG9vcDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uU3BlZWQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAncnRsJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3aWR0aDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDM2MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAyNzBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9yZGVyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzcGFjZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdhdXRvJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGFydEluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbGlja2FibGU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpc2FibGUzZDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1pblN3aXBlRGlzdGFuY2U6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludmVyc2VTY2FsaW5nOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogNTAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRyb2xzVmlzaWJsZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRyb2xzUHJldkh0bWw6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICcmbHNhcXVvOydcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udHJvbHNOZXh0SHRtbDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogJyZyc2FxdW87J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250cm9sc1dpZHRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogNTBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udHJvbHNIZWlnaHQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkxhc3RTbGlkZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBub29wXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU2xpZGVDaGFuZ2U6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbm9vcFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiaWFzOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnbGVmdCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogMCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcclxuICAgICAgICAgICAgICAgIHRvdGFsOiAwLFxyXG4gICAgICAgICAgICAgICAgbG9jazogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhZ1N0YXJ0WDogMCxcclxuICAgICAgICAgICAgICAgIG1vdXNlZG93bjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtcclxuICAgICAgICAgICAgYXV0b3BsYXlcclxuICAgICAgICBdLFxyXG4gICAgICAgIHdhdGNoOiB7XHJcbiAgICAgICAgICAgIGNvdW50ICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZURhdGEoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBpc0xhc3RTbGlkZSAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50SW5kZXggPT09IHRoaXMudG90YWwgLSAxXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzRmlyc3RTbGlkZSAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50SW5kZXggPT09IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNOZXh0UG9zc2libGUgKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoIXRoaXMubG9vcCAmJiB0aGlzLmlzTGFzdFNsaWRlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1ByZXZQb3NzaWJsZSAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISghdGhpcy5sb29wICYmIHRoaXMuaXNGaXJzdFNsaWRlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzbGlkZVdpZHRoICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZ3ID0gdGhpcy52aWV3cG9ydFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3cgPSBwYXJzZUludCh0aGlzLndpZHRoKSArIChwYXJzZUludCh0aGlzLmJvcmRlciwgMTApICogMilcclxuICAgICAgICAgICAgICAgIHJldHVybiB2dyA8IHN3ID8gdncgOiBzd1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzbGlkZUhlaWdodCAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdyA9IHBhcnNlSW50KHRoaXMud2lkdGgsIDEwKSArIChwYXJzZUludCh0aGlzLmJvcmRlciwgMTApICogMilcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNoID0gcGFyc2VJbnQocGFyc2VJbnQodGhpcy5oZWlnaHQpICsgKHRoaXMuYm9yZGVyICogMiksIDEwKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXIgPSB0aGlzLmNhbGN1bGF0ZUFzcGVjdFJhdGlvKHN3LCBzaClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlV2lkdGggLyBhclxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB2aXNpYmxlICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAodGhpcy5kaXNwbGF5ID4gdGhpcy50b3RhbCkgPyB0aGlzLnRvdGFsIDogdGhpcy5kaXNwbGF5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYXNIaWRkZW5TbGlkZXMgKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWwgPiB0aGlzLnZpc2libGVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVmdEluZGljZXMgKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSAodGhpcy52aXNpYmxlIC0gMSkgLyAyXHJcbiAgICAgICAgICAgICAgICBuID0gKHRoaXMuYmlhcy50b0xvd2VyQ2FzZSgpID09PSAnbGVmdCcgPyBNYXRoLmNlaWwobikgOiBNYXRoLmZsb29yKG4pKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFtdXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtID0gMTsgbSA8PSBuOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goKHRoaXMuZGlyID09PSAnbHRyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5jdXJyZW50SW5kZXggKyBtKSAlICh0aGlzLnRvdGFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmN1cnJlbnRJbmRleCAtIG0pICUgKHRoaXMudG90YWwpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmlnaHRJbmRpY2VzICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuID0gKHRoaXMudmlzaWJsZSAtIDEpIC8gMlxyXG4gICAgICAgICAgICAgICAgbiA9ICh0aGlzLmJpYXMudG9Mb3dlckNhc2UoKSA9PT0gJ3JpZ2h0JyA/IE1hdGguY2VpbChuKSA6IE1hdGguZmxvb3IobikpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gW11cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IG47IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaCgodGhpcy5kaXIgPT09ICdsdHInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmN1cnJlbnRJbmRleCAtIG0pICUgKHRoaXMudG90YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY3VycmVudEluZGV4ICsgbSkgJSAodGhpcy50b3RhbCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kaWNlc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWZ0T3V0SW5kZXggKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSAodGhpcy52aXNpYmxlIC0gMSkgLyAyXHJcbiAgICAgICAgICAgICAgICBuID0gKHRoaXMuYmlhcy50b0xvd2VyQ2FzZSgpID09PSAnbGVmdCcgPyBNYXRoLmNlaWwobikgOiBNYXRoLmZsb29yKG4pKVxyXG4gICAgICAgICAgICAgICAgbisrXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXIgPT09ICdsdHInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodGhpcy50b3RhbCAtIHRoaXMuY3VycmVudEluZGV4IC0gbikgPD0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoLXBhcnNlSW50KHRoaXMudG90YWwgLSB0aGlzLmN1cnJlbnRJbmRleCAtIG4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmN1cnJlbnRJbmRleCArIG4pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jdXJyZW50SW5kZXggLSBuKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByaWdodE91dEluZGV4ICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuID0gKHRoaXMudmlzaWJsZSAtIDEpIC8gMlxyXG4gICAgICAgICAgICAgICAgbiA9ICh0aGlzLmJpYXMudG9Mb3dlckNhc2UoKSA9PT0gJ3JpZ2h0JyA/IE1hdGguY2VpbChuKSA6IE1hdGguZmxvb3IobikpXHJcbiAgICAgICAgICAgICAgICBuKytcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpciA9PT0gJ2x0cicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY3VycmVudEluZGV4IC0gbilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodGhpcy50b3RhbCAtIHRoaXMuY3VycmVudEluZGV4IC0gbikgPD0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoLXBhcnNlSW50KHRoaXMudG90YWwgLSB0aGlzLmN1cnJlbnRJbmRleCAtIG4sIDEwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5jdXJyZW50SW5kZXggKyBuKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHbyB0byBuZXh0IHNsaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnb05leHQgKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UG9zc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTGFzdFNsaWRlID8gdGhpcy5nb1NsaWRlKDApIDogdGhpcy5nb1NsaWRlKHRoaXMuY3VycmVudEluZGV4ICsgMSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdvIHRvIHByZXZpb3VzIHNsaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnb1ByZXYgKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmV2UG9zc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRmlyc3RTbGlkZSA/IHRoaXMuZ29TbGlkZSh0aGlzLnRvdGFsIC0gMSkgOiB0aGlzLmdvU2xpZGUodGhpcy5jdXJyZW50SW5kZXggLSAxKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR28gdG8gc2xpZGVcclxuICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBpbmRleCBvZiBzbGlkZSB3aGVyZSB0byBnb1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ29TbGlkZSAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMudG90YWwgLSAxKSA/IDAgOiBpbmRleFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NrID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXN0U2xpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkxhc3RTbGlkZSAhPT0gbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ29uTGFzdFNsaWRlIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQGxhc3Qtc2xpZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGFzdFNsaWRlKHRoaXMuY3VycmVudEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2xhc3Qtc2xpZGUnLCB0aGlzLmN1cnJlbnRJbmRleClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZS1zbGlkZS1jaGFuZ2UnLCB0aGlzLmN1cnJlbnRJbmRleClcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hbmltYXRpb25FbmQoKSwgdGhpcy5hbmltYXRpb25TcGVlZClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdvIHRvIHNsaWRlIGZhciBzbGlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ29GYXIgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IChpbmRleCA9PT0gdGhpcy50b3RhbCAtIDEgJiYgdGhpcy5pc0ZpcnN0U2xpZGUpID8gLTEgOiAoaW5kZXggLSB0aGlzLmN1cnJlbnRJbmRleClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFNsaWRlICYmIGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYyID0gKGRpZmYgPCAwKSA/IC1kaWZmIDogZGlmZlxyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWVCdWZmID0gMFxyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGRpZmYyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IChkaWZmMiA9PT0gMSkgPyAwIDogKHRpbWVCdWZmKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gKGRpZmYgPCAwKSA/IHRoaXMuZ29QcmV2KGRpZmYyKSA6IHRoaXMuZ29OZXh0KGRpZmYyKSwgdGltZW91dClcclxuICAgICAgICAgICAgICAgICAgICB0aW1lQnVmZiArPSAodGhpcy5hbmltYXRpb25TcGVlZCAvIChkaWZmMikpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUcmlnZ2VyIGFjdGlvbnMgd2hlbiBhbmltYXRpb24gZW5kc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgYW5pbWF0aW9uRW5kICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jayA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblNsaWRlQ2hhbmdlICE9PSBub29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdvblNsaWRlQ2hhbmdlIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQGFmdGVyLXNsaWRlLWNoYW5nZScpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2xpZGVDaGFuZ2UodGhpcy5jdXJyZW50SW5kZXgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdhZnRlci1zbGlkZS1jaGFuZ2UnLCB0aGlzLmN1cnJlbnRJbmRleClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRyaWdnZXIgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBoYW5kbGVNb3VzZXVwICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2Vkb3duID0gZmFsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldCA9IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRyaWdnZXIgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHByZXNzZWRcclxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlZG93biAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlLnRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRYID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJpZ2dlciBhY3Rpb25zIHdoZW4gbW91c2UgaXMgcHJlc3NlZCBhbmQgdGhlbiBtb3ZlZCAobW91c2UgZHJhZylcclxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlbW92ZSAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRQb3NYID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gKHRoaXMuZHJhZ1N0YXJ0WCAtIGV2ZW50UG9zWClcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldCA9IGRlbHRhWFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ09mZnNldCA+IHRoaXMubWluU3dpcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2V1cCgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb05leHQoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdPZmZzZXQgPCAtdGhpcy5taW5Td2lwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZXVwKClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvUHJldigpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG11dGF0aW9uIG9ic2VydmVyIGlzIHVzZWQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIGNvbnRhaW5pbmcgbm9kZVxyXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byBrZWVwIHRoZSBtYWduZXQgY29udGFpbmVyIGluIHN5bmMgd2l0aCB0aGUgaGVpZ2h0IGl0cyByZWZlcmVuY2Ugbm9kZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGF0dGFjaE11dGF0aW9uT2JzZXJ2ZXIgKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlclxyXG4gICAgICAgICAgICAgICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZURhdGEoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLCBjb25maWcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcCBsaXN0ZW5pbmcgdG8gbXV0YXRpb24gY2hhbmdlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZGV0YWNoTXV0YXRpb25PYnNlcnZlciAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2Ygc2xpZGVzXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIG9mIHNsaWRlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0U2xpZGVDb3VudCAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2xvdHMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzLmRlZmF1bHQuZmlsdGVyKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGFnICE9PSB2b2lkIDBcclxuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGUgc2xpZGUgd2l0aCBhbmQga2VlcCBkZWZpbmVkIGFzcGVjdCByYXRpb1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFzcGVjdCByYXRpbyBudW1iZXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZUFzcGVjdFJhdGlvICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4od2lkdGggLyBoZWlnaHQpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZS1jb21wdXRlIHRoZSBudW1iZXIgb2Ygc2xpZGVzIGFuZCBjdXJyZW50IHNsaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb21wdXRlRGF0YSAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5nZXRTbGlkZUNvdW50KClcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gcGFyc2VJbnQodGhpcy5zdGFydEluZGV4KSA+IHRoaXMudG90YWwgLSAxID8gdGhpcy50b3RhbCAtIDEgOiBwYXJzZUludCh0aGlzLnN0YXJ0SW5kZXgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy4kZWwuY2xpZW50V2lkdGhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0U2l6ZSAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5zdHlsZS5jc3NUZXh0ICs9ICdoZWlnaHQ6JyArIHRoaXMuc2xpZGVIZWlnaHQgKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuY2hpbGROb2Rlc1swXS5zdHlsZS5jc3NUZXh0ICs9ICd3aWR0aDonICsgdGhpcy5zbGlkZVdpZHRoICsgJ3B4OycgKyAnIGhlaWdodDonICsgdGhpcy5zbGlkZUhlaWdodCArICdweDsnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdW50ZWQgKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRhKClcclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hNdXRhdGlvbk9ic2VydmVyKClcclxuICAgICAgICAgICAgaWYgKCF0aGlzLiRpc1NlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc2V0U2l6ZSlcclxuICAgICAgICAgICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb3VzZWRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNldXApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZW1vdmUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNldXApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZW1vdmUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGlzU2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaE11dGF0aW9uT2JzZXJ2ZXIoKVxyXG4gICAgICAgICAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2Vtb3ZlKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlbW92ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnNldFNpemUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIHNjb3BlZD5cclxuICAgIC5jYXJvdXNlbC0zZC1jb250YWluZXIge1xyXG4gICAgICAgIG1pbi1oZWlnaHQ6IDFweDtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgei1pbmRleDogMDtcclxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgIG1hcmdpbjogMjBweCBhdXRvO1xyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICB9XHJcbiAgICAuY2Fyb3VzZWwtM2Qtc2xpZGVyIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcclxuICAgICAgICAtd2Via2l0LXBlcnNwZWN0aXZlOiAxMDAwcHg7XHJcbiAgICAgICAgLW1vei1wZXJzcGVjdGl2ZTogMTAwMHB4O1xyXG4gICAgICAgIHBlcnNwZWN0aXZlOiAxMDAwcHg7XHJcbiAgICB9XHJcbjwvc3R5bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGRlbW8vY2Fyb3VzZWwudnVlPzZiMmY0NjlhIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1iY2FhMGFmNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL3NsaWRlLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zbGlkZS52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zbGlkZS52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWJjYWEwYWY0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NsaWRlLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJkZW1vXFxcXHNsaWRlLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1iY2FhMGFmNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWJjYWEwYWY0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGVtby9zbGlkZS52dWVcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBcclxuICAgIGNsYXNzPVwiY2Fyb3VzZWwtM2Qtc2xpZGVcIiBcclxuICAgIDpzdHlsZT1cInNsaWRlU3R5bGVcIiBcclxuICAgIDpjbGFzcz1cInsgJ2N1cnJlbnQnOiBpc0N1cnJlbnQgfVwiIFxyXG4gICAgQGNsaWNrPVwiZ29UbygpXCI+XHJcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIG5hbWU6ICdzbGlkZScsXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgaW5kZXg6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkYXRhICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy4kcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgIHpJbmRleDogOTk5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICAgIGlzQ3VycmVudCAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudEluZGV4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNsaWRlU3R5bGUgKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlcyA9IHt9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgckluZGV4ID0gdGhpcy5nZXRTaWRlSW5kZXgodGhpcy5wYXJlbnQucmlnaHRJbmRpY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxJbmRleCA9IHRoaXMuZ2V0U2lkZUluZGV4KHRoaXMucGFyZW50LmxlZnRJbmRpY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChySW5kZXggPj0gMCB8fCBsSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBySW5kZXggPj0gMCA/IHRoaXMuY2FsY3VsYXRlUG9zaXRpb24ockluZGV4LCB0cnVlLCB0aGlzLnpJbmRleCkgOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uKGxJbmRleCwgZmFsc2UsIHRoaXMuekluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Lmhhc0hpZGRlblNsaWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEluZGV4KHRoaXMucGFyZW50LmxlZnRPdXRJbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHRoaXMuY2FsY3VsYXRlUG9zaXRpb24odGhpcy5wYXJlbnQubGVmdEluZGljZXMubGVuZ3RoIC0gMSwgZmFsc2UsIHRoaXMuekluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2hJbmRleCh0aGlzLnBhcmVudC5yaWdodE91dEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbih0aGlzLnBhcmVudC5yaWdodEluZGljZXMubGVuZ3RoIC0gMSwgdHJ1ZSwgdGhpcy56SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdHlsZXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogdGhpcy5wYXJlbnQuYm9yZGVyICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiB0aGlzLnBhcmVudC5zbGlkZVdpZHRoICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogdGhpcy5wYXJlbnQuc2xpZGVIZWlnaHQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJyB0cmFuc2Zvcm0gJyArIHRoaXMucGFyZW50LmFuaW1hdGlvblNwZWVkICsgJ21zLCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnICAgICAgICAgICAgICAgb3BhY2l0eSAnICsgdGhpcy5wYXJlbnQuYW5pbWF0aW9uU3BlZWQgKyAnbXMsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgICAgICAgICAgICAgICB2aXNpYmlsaXR5ICcgKyB0aGlzLnBhcmVudC5hbmltYXRpb25TcGVlZCArICdtcydcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgZ2V0U2lkZUluZGV4IChhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gLTFcclxuICAgICAgICAgICAgICAgIGFycmF5LmZvckVhY2goKHBvcywgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoSW5kZXgocG9zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1hdGNoSW5kZXggKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4ID49IDApID8gdGhpcy5pbmRleCA9PT0gaW5kZXggOiAodGhpcy5wYXJlbnQudG90YWwgKyBpbmRleCkgPT09IHRoaXMuaW5kZXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gKGksIHBvc2l0aXZlLCB6SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSAhdGhpcy5wYXJlbnQuZGlzYWJsZTNkID8gcGFyc2VJbnQodGhpcy5wYXJlbnQuaW52ZXJzZVNjYWxpbmcpICsgKChpICsgMSkgKiAxMDApIDogMFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9ICF0aGlzLnBhcmVudC5kaXNhYmxlM2QgPyBwYXJzZUludCh0aGlzLnBhcmVudC5wZXJzcGVjdGl2ZSkgOiAwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVtYWluID0gKHRoaXMucGFyZW50LnNwYWNlID09PSAnYXV0bycpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludCgoaSArIDEpICogKHRoaXMucGFyZW50LndpZHRoIC8gMS41KSwgMTApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJzZUludCgoaSArIDEpICogKHRoaXMucGFyZW50LnNwYWNlKSwgMTApXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSAocG9zaXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAndHJhbnNsYXRlWCgnICsgKGxlZnRSZW1haW4pICsgJ3B4KSB0cmFuc2xhdGVaKC0nICsgeiArICdweCkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0ZVkoLScgKyB5ICsgJ2RlZyknXHJcbiAgICAgICAgICAgICAgICAgICAgOiAndHJhbnNsYXRlWCgtJyArIChsZWZ0UmVtYWluKSArICdweCkgdHJhbnNsYXRlWigtJyArIHogKyAncHgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdyb3RhdGVZKCcgKyB5ICsgJ2RlZyknXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBhcmVudC5zcGFjZSA9PT0gJ2F1dG8nID8gMCA6IHBhcnNlSW50KChpICsgMSkgKiAodGhpcy5wYXJlbnQuc3BhY2UpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICAgICAgICAgICAgICAvLyB6SW5kZXg6IHpJbmRleCAtIChNYXRoLmFicyhpKSArIDEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdvVG8gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmNsaWNrYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmdvRmFyKHRoaXMuaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG4gICAgLmNhcm91c2VsLTNkLXNsaWRlIHtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgb3BhY2l0eTogMDtcclxuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XHJcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICB0b3A6IDA7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMXB4O1xyXG4gICAgICAgIGJvcmRlci1jb2xvcjogIzAwMDtcclxuICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcclxuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xyXG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcclxuICAgICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgIH1cclxuICAgIC5jYXJvdXNlbC0zZC1zbGlkZSB7XHJcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcclxuICAgIH1cclxuICAgIC5jYXJvdXNlbC0zZC1zbGlkZSBpbWcge1xyXG4gICAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgfVxyXG4gICAgLmNhcm91c2VsLTNkLXNsaWRlLmN1cnJlbnQge1xyXG4gICAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcclxuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgei1pbmRleDogOTk5O1xyXG4gICAgfVxyXG48L3N0eWxlPlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkZW1vL3NsaWRlLnZ1ZT81MmE2OTM0OCIsImltcG9ydCBWdWUgZnJvbSAnLi92dWUuanMnO1xyXG4vLyBpbXBvcnQgU2xpZGVTaG93IGZyb20gJy4vdGVzdC52dWUnO1xyXG5pbXBvcnQgY2Fyb3VzZWwzZCBmcm9tICcuL2Nhcm91c2VsLnZ1ZSc7XHJcbmltcG9ydCBzbGlkZSBmcm9tICcuL3NsaWRlLnZ1ZSc7XHJcblxyXG5uZXcgVnVlKHtcclxuICBlbDogJy5hcHAnLFxyXG4gIGNvbXBvbmVudHM6IHsgY2Fyb3VzZWwzZCwgc2xpZGUgfSxcclxuICAvLyBjb21wb25lbnRzOiB7U2xpZGVTaG93fSxcclxuICAvLyBkYXRhOiB7XHJcbiAgLy8gICBpbnZUaW1lOiAyMDAwLFxyXG4gIC8vICAgYXV0b1BsYXk6IGZhbHNlLFxyXG4gIC8vICAgc2xpZGVzOiBbXHJcbiAgLy8gICAgIHtcclxuICAvLyAgICAgICBzcmM6IHJlcXVpcmUoJy4vaW1hZ2VzLzEuanBnJyksXHJcbiAgLy8gICAgICAgdGl0bGU6ICd4eHgxJyxcclxuICAvLyAgICAgICBocmVmOiAnZGV0YWlsL2FuYWx5c2lzJyxcclxuICAvLyAgICAgICBpZDogMFxyXG4gIC8vICAgICB9LFxyXG4gIC8vICAgICB7XHJcbiAgLy8gICAgICAgc3JjOiByZXF1aXJlKCcuL2ltYWdlcy8yLmpwZycpLFxyXG4gIC8vICAgICAgIHRpdGxlOiAneHh4MicsXHJcbiAgLy8gICAgICAgaHJlZjogJ2RldGFpbC9jb3VudCcsXHJcbiAgLy8gICAgICAgaWQ6IDFcclxuICAvLyAgICAgfSxcclxuICAvLyAgICAge1xyXG4gIC8vICAgICAgIHNyYzogcmVxdWlyZSgnLi9pbWFnZXMvMy5qcGcnKSxcclxuICAvLyAgICAgICB0aXRsZTogJ3h4eDMnLFxyXG4gIC8vICAgICAgIGhyZWY6ICdodHRwOi8veHh4Lnh4eC5jb20nLFxyXG4gIC8vICAgICAgIGlkOiAyXHJcbiAgLy8gICAgIH0sXHJcbiAgLy8gICAgIHtcclxuICAvLyAgICAgICBzcmM6IHJlcXVpcmUoJy4vaW1hZ2VzLzQuanBnJyksXHJcbiAgLy8gICAgICAgdGl0bGU6ICd4eHg0JyxcclxuICAvLyAgICAgICBocmVmOiAnZGV0YWlsL2ZvcmVjYXN0JyxcclxuICAvLyAgICAgICBpZDogM1xyXG4gIC8vICAgICB9LFxyXG4gIC8vICAgICB7XHJcbiAgLy8gICAgICAgc3JjOiByZXF1aXJlKCcuL2ltYWdlcy81LmpwZycpLFxyXG4gIC8vICAgICAgIHRpdGxlOiAneHh4NCcsXHJcbiAgLy8gICAgICAgaHJlZjogJ2RldGFpbC9mb3JlY2FzdCcsXHJcbiAgLy8gICAgICAgaWQ6IDRcclxuICAvLyAgICAgfVxyXG4gIC8vICAgXVxyXG4gIC8vIH1cclxuICBkYXRhOiB7XHJcbiAgICBhdXRvcGxheTogZmFsc2UsXHJcbiAgICBzcGFjZTogMzAwXHJcbiAgfVxyXG5cclxufSlcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZGVtby9tYWluLmpzIiwiLyohXHJcbiAqIFZ1ZS5qcyB2Mi41LjhcclxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxyXG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAgIChnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcclxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xyXG5cclxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXHJcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcclxuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcclxuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XHJcbiAgcmV0dXJuIHYgPT09IHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xyXG4gIHJldHVybiB2ID09PSBmYWxzZVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcclxuICByZXR1cm4gKFxyXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxyXG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxyXG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcclxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxyXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxyXG4gKi9cclxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XHJcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcclxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xyXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xyXG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XHJcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xyXG4gIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgPyAnJ1xyXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xyXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcclxuICAgICAgOiBTdHJpbmcodmFsKVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cclxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XHJcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcCAoXHJcbiAgc3RyLFxyXG4gIGV4cGVjdHNMb3dlckNhc2VcclxuKSB7XHJcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXHJcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cclxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxyXG4gKi9cclxudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXHJcbiAqL1xyXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcclxuICBpZiAoYXJyLmxlbmd0aCkge1xyXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cclxuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcclxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcclxuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xyXG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cclxuICovXHJcbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxyXG4gKi9cclxudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcclxufSk7XHJcblxyXG4vKipcclxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cclxuICovXHJcbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcclxufSk7XHJcblxyXG4vKipcclxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxyXG4gKi9cclxuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xyXG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcclxuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHJldHVybiBsXHJcbiAgICAgID8gbCA+IDFcclxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxyXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXHJcbiAgICAgIDogZm4uY2FsbChjdHgpXHJcbiAgfVxyXG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcclxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XHJcbiAgcmV0dXJuIGJvdW5kRm5cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcclxuICBzdGFydCA9IHN0YXJ0IHx8IDA7XHJcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xyXG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xyXG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xyXG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiB0b1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChhcnJbaV0pIHtcclxuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXHJcbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxyXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcclxuICovXHJcbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XHJcblxyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxyXG4gKi9cclxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xyXG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xyXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcclxuICB9LCBbXSkuam9pbignLCcpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcclxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xyXG4gKi9cclxuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xyXG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cclxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XHJcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xyXG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xyXG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xyXG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcclxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XHJcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxyXG4gIH1cclxuICByZXR1cm4gLTFcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbmNlIChmbikge1xyXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XHJcblxyXG52YXIgQVNTRVRfVFlQRVMgPSBbXHJcbiAgJ2NvbXBvbmVudCcsXHJcbiAgJ2RpcmVjdGl2ZScsXHJcbiAgJ2ZpbHRlcidcclxuXTtcclxuXHJcbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXHJcbiAgJ2JlZm9yZUNyZWF0ZScsXHJcbiAgJ2NyZWF0ZWQnLFxyXG4gICdiZWZvcmVNb3VudCcsXHJcbiAgJ21vdW50ZWQnLFxyXG4gICdiZWZvcmVVcGRhdGUnLFxyXG4gICd1cGRhdGVkJyxcclxuICAnYmVmb3JlRGVzdHJveScsXHJcbiAgJ2Rlc3Ryb3llZCcsXHJcbiAgJ2FjdGl2YXRlZCcsXHJcbiAgJ2RlYWN0aXZhdGVkJyxcclxuICAnZXJyb3JDYXB0dXJlZCdcclxuXTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGNvbmZpZyA9ICh7XHJcbiAgLyoqXHJcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXHJcbiAgICovXHJcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxyXG4gICAqL1xyXG4gIHNpbGVudDogZmFsc2UsXHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XHJcbiAgICovXHJcbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXHJcbiAgICovXHJcbiAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXHJcbiAgICovXHJcbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xyXG4gICAqL1xyXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXHJcbiAgICovXHJcbiAgd2FybkhhbmRsZXI6IG51bGwsXHJcblxyXG4gIC8qKlxyXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xyXG4gICAqL1xyXG4gIGlnbm9yZWRFbGVtZW50czogW10sXHJcblxyXG4gIC8qKlxyXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXHJcbiAgICovXHJcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxyXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cclxuICAgKi9cclxuICBpc1Jlc2VydmVkVGFnOiBubyxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcclxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAqL1xyXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxyXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cclxuICAgKi9cclxuICBpc1Vua25vd25FbGVtZW50OiBubyxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxyXG4gICAqL1xyXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cclxuICAgKi9cclxuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXHJcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxyXG4gICAqL1xyXG4gIG11c3RVc2VQcm9wOiBubyxcclxuXHJcbiAgLyoqXHJcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcclxuICAgKi9cclxuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xyXG4gKi9cclxuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XHJcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XHJcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGEgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIHZhbHVlOiB2YWwsXHJcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2Ugc2ltcGxlIHBhdGguXHJcbiAqL1xyXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcclxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XHJcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XHJcbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcblxyXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cclxudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XHJcblxyXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXHJcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XHJcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xyXG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcclxudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XHJcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcclxudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xyXG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xyXG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcclxuXHJcbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cclxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcclxuXHJcbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuaWYgKGluQnJvd3Nlcikge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgb3B0cyA9IHt9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcbiAgfSBjYXRjaCAoZSkge31cclxufVxyXG5cclxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXHJcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXHJcbnZhciBfaXNTZXJ2ZXI7XHJcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXHJcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcclxuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfaXNTZXJ2ZXJcclxufTtcclxuXHJcbi8vIGRldGVjdCBkZXZ0b29sc1xyXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xyXG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxyXG59XHJcblxyXG52YXIgaGFzU3ltYm9sID1cclxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXHJcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XHJcblxyXG52YXIgX1NldDtcclxuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xyXG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxyXG4gIF9TZXQgPSBTZXQ7XHJcbn0gZWxzZSB7XHJcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxyXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcclxuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxyXG4gICAgfTtcclxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcclxuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcclxuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gU2V0O1xyXG4gIH0oKSk7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHdhcm4gPSBub29wO1xyXG52YXIgdGlwID0gbm9vcDtcclxudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcclxudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XHJcblxyXG57XHJcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxyXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xyXG5cclxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcclxuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcclxuXHJcbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XHJcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcclxuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXHJcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XHJcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XHJcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcclxuICAgICAgPyB2bS5vcHRpb25zXHJcbiAgICAgIDogdm0uX2lzVnVlXHJcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXHJcbiAgICAgICAgOiB2bSB8fCB7fTtcclxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcclxuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XHJcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xyXG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcclxuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xyXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxyXG4gICAgKVxyXG4gIH07XHJcblxyXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XHJcbiAgICB2YXIgcmVzID0gJyc7XHJcbiAgICB3aGlsZSAobikge1xyXG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxyXG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxyXG4gICAgICBuID4+PSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH07XHJcblxyXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcclxuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xyXG4gICAgICB2YXIgdHJlZSA9IFtdO1xyXG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcclxuICAgICAgd2hpbGUgKHZtKSB7XHJcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XHJcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xyXG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcclxuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcclxuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcclxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXHJcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcclxuICAgICAgICAuam9pbignXFxuJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5cclxudmFyIHVpZCA9IDA7XHJcblxyXG4vKipcclxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXHJcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXHJcbiAqL1xyXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcclxuICB0aGlzLmlkID0gdWlkKys7XHJcbiAgdGhpcy5zdWJzID0gW107XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XHJcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcclxufTtcclxuXHJcbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcclxuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xyXG59O1xyXG5cclxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xyXG4gIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcclxuICB9XHJcbn07XHJcblxyXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XHJcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcclxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHN1YnNbaV0udXBkYXRlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxyXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXHJcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxyXG5EZXAudGFyZ2V0ID0gbnVsbDtcclxudmFyIHRhcmdldFN0YWNrID0gW107XHJcblxyXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XHJcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxyXG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xyXG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXHJcbiAgdGFnLFxyXG4gIGRhdGEsXHJcbiAgY2hpbGRyZW4sXHJcbiAgdGV4dCxcclxuICBlbG0sXHJcbiAgY29udGV4dCxcclxuICBjb21wb25lbnRPcHRpb25zLFxyXG4gIGFzeW5jRmFjdG9yeVxyXG4pIHtcclxuICB0aGlzLnRhZyA9IHRhZztcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gIHRoaXMuZWxtID0gZWxtO1xyXG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMuZnVuY3Rpb25hbE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5mdW5jdGlvbmFsU2NvcGVJZCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XHJcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcclxuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMucmF3ID0gZmFsc2U7XHJcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xyXG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcclxuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xyXG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcclxuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xyXG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xyXG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xyXG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xyXG5cclxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcclxuXHJcbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcclxuXHJcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcclxuICBub2RlLnRleHQgPSB0ZXh0O1xyXG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcclxuICByZXR1cm4gbm9kZVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcclxuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxyXG59XHJcblxyXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxyXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXHJcbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxyXG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSwgZGVlcCkge1xyXG4gIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxyXG4gICAgdm5vZGUudGFnLFxyXG4gICAgdm5vZGUuZGF0YSxcclxuICAgIHZub2RlLmNoaWxkcmVuLFxyXG4gICAgdm5vZGUudGV4dCxcclxuICAgIHZub2RlLmVsbSxcclxuICAgIHZub2RlLmNvbnRleHQsXHJcbiAgICBjb21wb25lbnRPcHRpb25zLFxyXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XHJcbiAgKTtcclxuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcclxuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcclxuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xyXG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XHJcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcclxuICBpZiAoZGVlcCkge1xyXG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChjb21wb25lbnRPcHRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pIHtcclxuICAgICAgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sIHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY2xvbmVkXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMsIGRlZXApIHtcclxuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcclxuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0sIGRlZXApO1xyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qXHJcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxyXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcclxuICovXHJcblxyXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcclxudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xyXG4gICdwdXNoJyxcclxuICAncG9wJyxcclxuICAnc2hpZnQnLFxyXG4gICd1bnNoaWZ0JyxcclxuICAnc3BsaWNlJyxcclxuICAnc29ydCcsXHJcbiAgJ3JldmVyc2UnXHJcbl1cclxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxyXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcclxuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XHJcbiAgICB2YXIgaW5zZXJ0ZWQ7XHJcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xyXG4gICAgICBjYXNlICdwdXNoJzpcclxuICAgICAgY2FzZSAndW5zaGlmdCc6XHJcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ3NwbGljZSc6XHJcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxyXG4gICAgLy8gbm90aWZ5IGNoYW5nZVxyXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XHJcblxyXG4vKipcclxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xyXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXHJcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcclxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXHJcbiAqL1xyXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcclxuICBzaG91bGRDb252ZXJ0OiB0cnVlXHJcbn07XHJcblxyXG4vKipcclxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxyXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcclxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcclxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cclxuICovXHJcbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xyXG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcclxuICB0aGlzLnZtQ291bnQgPSAwO1xyXG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xyXG4gICAgICA/IHByb3RvQXVnbWVudFxyXG4gICAgICA6IGNvcHlBdWdtZW50O1xyXG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xyXG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLndhbGsodmFsdWUpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cclxuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXHJcbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxyXG4gKi9cclxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxyXG4gKi9cclxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gaGVscGVyc1xyXG5cclxuLyoqXHJcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcclxuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cclxuICovXHJcbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcclxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xyXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XHJcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xyXG59XHJcblxyXG4vKipcclxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXHJcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcclxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcclxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xyXG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb2I7XHJcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XHJcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXHJcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxyXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxyXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcclxuICAgICF2YWx1ZS5faXNWdWVcclxuICApIHtcclxuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcclxuICB9XHJcbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcclxuICAgIG9iLnZtQ291bnQrKztcclxuICB9XHJcbiAgcmV0dXJuIG9iXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXHJcbiAgb2JqLFxyXG4gIGtleSxcclxuICB2YWwsXHJcbiAgY3VzdG9tU2V0dGVyLFxyXG4gIHNoYWxsb3dcclxuKSB7XHJcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcclxuXHJcbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XHJcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXHJcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcclxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xyXG5cclxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xyXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcclxuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGVyKSB7XHJcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcclxuICAgICAgfVxyXG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xyXG4gICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcclxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxyXG4gKiBhbHJlYWR5IGV4aXN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XHJcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcclxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xyXG4gICAgcmV0dXJuIHZhbFxyXG4gIH1cclxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xyXG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcclxuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcclxuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcclxuICAgICk7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG4gIGlmICghb2IpIHtcclxuICAgIHRhcmdldFtrZXldID0gdmFsO1xyXG4gICAgcmV0dXJuIHZhbFxyXG4gIH1cclxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xyXG4gIG9iLmRlcC5ub3RpZnkoKTtcclxuICByZXR1cm4gdmFsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xyXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcclxuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xyXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcclxuICAgICk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgZGVsZXRlIHRhcmdldFtrZXldO1xyXG4gIGlmICghb2IpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBvYi5kZXAubm90aWZ5KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxyXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xyXG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIGUgPSB2YWx1ZVtpXTtcclxuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgZGVwZW5kQXJyYXkoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXHJcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXHJcbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxyXG4gKi9cclxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XHJcblxyXG4vKipcclxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xyXG4gKi9cclxue1xyXG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXHJcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcclxuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cclxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAga2V5ID0ga2V5c1tpXTtcclxuICAgIHRvVmFsID0gdG9ba2V5XTtcclxuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XHJcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xyXG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcclxuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRvXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm1cclxuKSB7XHJcbiAgaWYgKCF2bSkge1xyXG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcclxuICAgIGlmICghY2hpbGRWYWwpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkVmFsXHJcbiAgICB9XHJcbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXHJcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcclxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xyXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXHJcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cclxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xyXG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxyXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcclxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcykgOiBwYXJlbnRWYWxcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xyXG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxyXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxyXG4gICAgICAgIDogY2hpbGRWYWw7XHJcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxyXG4gICAgICAgIDogcGFyZW50VmFsO1xyXG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm1cclxuKSB7XHJcbiAgaWYgKCF2bSkge1xyXG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50VmFsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXHJcbn07XHJcblxyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VIb29rIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWxcclxuKSB7XHJcbiAgcmV0dXJuIGNoaWxkVmFsXHJcbiAgICA/IHBhcmVudFZhbFxyXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcclxuICAgICAgICA/IGNoaWxkVmFsXHJcbiAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICA6IHBhcmVudFZhbFxyXG59XHJcblxyXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xyXG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcclxufSk7XHJcblxyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICBpZiAoY2hpbGRWYWwpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xyXG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG59XHJcblxyXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFdhdGNoZXJzLlxyXG4gKlxyXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXHJcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxyXG4gKi9cclxuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxyXG4gIHBhcmVudFZhbCxcclxuICBjaGlsZFZhbCxcclxuICB2bSxcclxuICBrZXlcclxuKSB7XHJcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cclxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxyXG4gIHtcclxuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xyXG4gIH1cclxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxyXG4gIHZhciByZXQgPSB7fTtcclxuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcclxuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xyXG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcclxuICAgIH1cclxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcclxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxyXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn07XHJcblxyXG4vKipcclxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cclxuICovXHJcbnN0cmF0cy5wcm9wcyA9XHJcbnN0cmF0cy5tZXRob2RzID1cclxuc3RyYXRzLmluamVjdCA9XHJcbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcclxuICBwYXJlbnRWYWwsXHJcbiAgY2hpbGRWYWwsXHJcbiAgdm0sXHJcbiAga2V5XHJcbikge1xyXG4gIGlmIChjaGlsZFZhbCAmJiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgfVxyXG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XHJcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcclxuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XHJcbiAgcmV0dXJuIHJldFxyXG59O1xyXG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBzdHJhdGVneS5cclxuICovXHJcbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xyXG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXHJcbiAgICA/IHBhcmVudFZhbFxyXG4gICAgOiBjaGlsZFZhbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xyXG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcclxuICAgICAgICAnaWQ6ICcgKyBrZXlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcclxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xyXG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxyXG4gIHZhciByZXMgPSB7fTtcclxuICB2YXIgaSwgdmFsLCBuYW1lO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xyXG4gICAgaSA9IHByb3BzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdmFsID0gcHJvcHNbaV07XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xyXG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xyXG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xyXG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xyXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgfVxyXG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XHJcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xyXG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XHJcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcclxuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxyXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluamVjdCkge1xyXG4gICAgd2FybihcclxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xyXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XHJcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XHJcbiAgaWYgKGRpcnMpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XHJcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XHJcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xyXG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xyXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxyXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcclxuICBwYXJlbnQsXHJcbiAgY2hpbGQsXHJcbiAgdm1cclxuKSB7XHJcbiAge1xyXG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XHJcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XHJcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XHJcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcclxuICBpZiAoZXh0ZW5kc0Zyb20pIHtcclxuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XHJcbiAgfVxyXG4gIGlmIChjaGlsZC5taXhpbnMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICB2YXIga2V5O1xyXG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xyXG4gICAgbWVyZ2VGaWVsZChrZXkpO1xyXG4gIH1cclxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XHJcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XHJcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb25zXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcclxuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcclxuICBvcHRpb25zLFxyXG4gIHR5cGUsXHJcbiAgaWQsXHJcbiAgd2Fybk1pc3NpbmdcclxuKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcclxuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxyXG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cclxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cclxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxyXG4gICAgICBvcHRpb25zXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcclxuICBrZXksXHJcbiAgcHJvcE9wdGlvbnMsXHJcbiAgcHJvcHNEYXRhLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcclxuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XHJcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XHJcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcclxuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcclxuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcclxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xyXG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxyXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXHJcbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XHJcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xyXG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XHJcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcclxuICB9XHJcbiAge1xyXG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xyXG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcclxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfVxyXG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XHJcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXHJcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcclxuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcclxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cclxuICB9XHJcbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcclxuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XHJcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXHJcbiAgICA/IGRlZi5jYWxsKHZtKVxyXG4gICAgOiBkZWZcclxufVxyXG5cclxuLyoqXHJcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxyXG4gIHByb3AsXHJcbiAgbmFtZSxcclxuICB2YWx1ZSxcclxuICB2bSxcclxuICBhYnNlbnRcclxuKSB7XHJcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcclxuICAgICAgdm1cclxuICAgICk7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcclxuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xyXG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XHJcbiAgaWYgKHR5cGUpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICB0eXBlID0gW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xyXG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XHJcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghdmFsaWQpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcclxuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xyXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcclxuICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcclxuXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XHJcbiAgdmFyIHZhbGlkO1xyXG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHZhbGlkOiB2YWxpZCxcclxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxyXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcclxuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcclxuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xyXG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAgaWYgKHZtKSB7XHJcbiAgICB2YXIgY3VyID0gdm07XHJcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xyXG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcclxuICAgICAgaWYgKGhvb2tzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcclxuICAgIH1cclxuICB9XHJcbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XHJcbiAge1xyXG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cclxuXHJcbnZhciBjYWxsYmFja3MgPSBbXTtcclxudmFyIHBlbmRpbmcgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcclxuICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29waWVzW2ldKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm8gYW5kIG1hY3JvIHRhc2tzLlxyXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcclxuLy8gbWljcm8gdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlcyBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcclxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcclxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcclxuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxyXG4vLyBIZXJlIHdlIHVzZSBtaWNybyB0YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgbWFjcm8gdGFzayB3aGVuXHJcbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cclxudmFyIG1pY3JvVGltZXJGdW5jO1xyXG52YXIgbWFjcm9UaW1lckZ1bmM7XHJcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcclxuXHJcbi8vIERldGVybWluZSAobWFjcm8pIFRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXHJcbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcclxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxyXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xyXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcclxuICB9O1xyXG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxyXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxyXG4gIC8vIFBoYW50b21KU1xyXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xyXG4pKSB7XHJcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcclxuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XHJcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcclxuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gRGV0ZXJtaW5lIE1pY3JvVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xyXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XHJcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XHJcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcclxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxyXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxyXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXHJcbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cclxuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcclxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIFRhc2sgaW5zdGVhZCBvZiBhIE1pY3JvVGFzay5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XHJcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcclxuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcclxuICB2YXIgX3Jlc29sdmU7XHJcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY2IuY2FsbChjdHgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xyXG4gICAgICBfcmVzb2x2ZShjdHgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGlmICghcGVuZGluZykge1xyXG4gICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XHJcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBtYXJrO1xyXG52YXIgbWVhc3VyZTtcclxuXHJcbntcclxuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKFxyXG4gICAgcGVyZiAmJlxyXG4gICAgcGVyZi5tYXJrICYmXHJcbiAgICBwZXJmLm1lYXN1cmUgJiZcclxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxyXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXHJcbiAgKSB7XHJcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XHJcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcclxuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xyXG5cclxudmFyIGluaXRQcm94eTtcclxuXHJcbntcclxuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxyXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXHJcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXHJcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xyXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcclxuICApO1xyXG5cclxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgIHdhcm4oXHJcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcclxuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXHJcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXHJcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcclxuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXHJcbiAgICAgIHRhcmdldFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB2YXIgaGFzUHJveHkgPVxyXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcclxuXHJcbiAgaWYgKGhhc1Byb3h5KSB7XHJcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XHJcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xyXG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzSGFuZGxlciA9IHtcclxuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xyXG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcclxuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xyXG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBnZXRIYW5kbGVyID0ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XHJcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XHJcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcclxuICAgIGlmIChoYXNQcm94eSkge1xyXG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcclxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxyXG4gICAgICAgID8gZ2V0SGFuZGxlclxyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcclxuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XHJcblxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcclxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcclxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcclxuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XHJcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcclxuICB2YXIgaSwga2V5cztcclxuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xyXG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBpZiAodmFsLl9fb2JfXykge1xyXG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XHJcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xyXG4gIH1cclxuICBpZiAoaXNBKSB7XHJcbiAgICBpID0gdmFsLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cclxuICB9IGVsc2Uge1xyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICBpID0ga2V5cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xyXG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcclxuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xyXG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxyXG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xyXG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6IG5hbWUsXHJcbiAgICBvbmNlOiBvbmNlJCQxLFxyXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcclxuICAgIHBhc3NpdmU6IHBhc3NpdmVcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcclxuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcclxuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcclxuXHJcbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XHJcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xyXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcclxuICAgIH1cclxuICB9XHJcbiAgaW52b2tlci5mbnMgPSBmbnM7XHJcbiAgcmV0dXJuIGludm9rZXJcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcclxuICBvbixcclxuICBvbGRPbixcclxuICBhZGQsXHJcbiAgcmVtb3ZlJCQxLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XHJcbiAgZm9yIChuYW1lIGluIG9uKSB7XHJcbiAgICBjdXIgPSBvbltuYW1lXTtcclxuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xyXG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcclxuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcclxuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcclxuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUpO1xyXG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xyXG4gICAgICBvbGQuZm5zID0gY3VyO1xyXG4gICAgICBvbltuYW1lXSA9IG9sZDtcclxuICAgIH1cclxuICB9XHJcbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XHJcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcclxuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcclxuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xyXG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xyXG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcclxuICB9XHJcbiAgdmFyIGludm9rZXI7XHJcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcclxuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcclxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXHJcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcclxuICB9XHJcblxyXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XHJcbiAgICAvLyBubyBleGlzdGluZyBob29rXHJcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xyXG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XHJcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xyXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xyXG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXHJcbiAgZGF0YSxcclxuICBDdG9yLFxyXG4gIHRhZ1xyXG4pIHtcclxuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cclxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcclxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxyXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcclxuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcclxuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xyXG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcclxuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxyXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRpcChcclxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xyXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xyXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcclxuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcclxuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcclxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxyXG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxyXG4gIHJlcyxcclxuICBoYXNoLFxyXG4gIGtleSxcclxuICBhbHRLZXksXHJcbiAgcHJlc2VydmVcclxuKSB7XHJcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XHJcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcclxuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XHJcbiAgICAgIGlmICghcHJlc2VydmUpIHtcclxuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XHJcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xyXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcclxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cclxuLy9cclxuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcclxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxyXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XHJcblxyXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcclxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXHJcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxyXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjaGlsZHJlblxyXG59XHJcblxyXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxyXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxyXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxyXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cclxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxyXG4gICAgICA6IHVuZGVmaW5lZFxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XHJcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XHJcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjID0gY2hpbGRyZW5baV07XHJcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cclxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xyXG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xyXG4gICAgLy8gIG5lc3RlZFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcclxuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XHJcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcclxuICAgICAgICAgIGMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xyXG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXHJcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXHJcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcclxuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxyXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXHJcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxyXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXHJcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcclxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXHJcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcclxuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzLnB1c2goYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcclxuICBpZiAoXHJcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcclxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcclxuICApIHtcclxuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBpc09iamVjdChjb21wKVxyXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxyXG4gICAgOiBjb21wXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxyXG4gIGZhY3RvcnksXHJcbiAgZGF0YSxcclxuICBjb250ZXh0LFxyXG4gIGNoaWxkcmVuLFxyXG4gIHRhZ1xyXG4pIHtcclxuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcclxuICByZXR1cm4gbm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxyXG4gIGZhY3RvcnksXHJcbiAgYmFzZUN0b3IsXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXHJcbiAgfVxyXG5cclxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcclxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXHJcbiAgfVxyXG5cclxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcclxuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xyXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xyXG4gICAgdmFyIHN5bmMgPSB0cnVlO1xyXG5cclxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxyXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcclxuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxyXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcclxuICAgICAgaWYgKCFzeW5jKSB7XHJcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcclxuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcclxuICAgICAgKTtcclxuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xyXG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XHJcblxyXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vICgpID0+IFByb21pc2VcclxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG5cclxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xyXG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xyXG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcclxuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcclxuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgICAgICByZWplY3QoXHJcbiAgICAgICAgICAgICAgICBcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCJcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3luYyA9IGZhbHNlO1xyXG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxyXG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xyXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcclxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XHJcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XHJcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xyXG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xyXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xyXG4gIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciB0YXJnZXQ7XHJcblxyXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSkge1xyXG4gIGlmIChvbmNlKSB7XHJcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xyXG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXHJcbiAgdm0sXHJcbiAgbGlzdGVuZXJzLFxyXG4gIG9sZExpc3RlbmVyc1xyXG4pIHtcclxuICB0YXJnZXQgPSB2bTtcclxuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcclxuICB0YXJnZXQgPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcclxuICB2YXIgaG9va1JFID0gL15ob29rOi87XHJcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcclxuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cclxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXHJcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcclxuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtXHJcbiAgfTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBmdW5jdGlvbiBvbiAoKSB7XHJcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcclxuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBvbi5mbiA9IGZuO1xyXG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XHJcbiAgICByZXR1cm4gdm1cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgLy8gYWxsXHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgIGlmICghY2JzKSB7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgaWYgKCFmbikge1xyXG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgIHJldHVybiB2bVxyXG4gICAgfVxyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgdmFyIGNiO1xyXG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkkMS0tKSB7XHJcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcclxuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bVxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICB7XHJcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcclxuICAgICAgICB0aXAoXHJcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcclxuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcclxuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xyXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xyXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgIGlmIChjYnMpIHtcclxuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XHJcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXHJcbiAgY2hpbGRyZW4sXHJcbiAgY29udGV4dFxyXG4pIHtcclxuICB2YXIgc2xvdHMgPSB7fTtcclxuICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICByZXR1cm4gc2xvdHNcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xyXG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxyXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcclxuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcclxuICAgIH1cclxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxyXG4gICAgLy8gc2FtZSBjb250ZXh0LlxyXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxyXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXHJcbiAgICApIHtcclxuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XHJcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XHJcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXHJcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XHJcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XHJcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2xvdHNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XHJcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXHJcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxyXG4gIHJlc1xyXG4pIHtcclxuICByZXMgPSByZXMgfHwge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcclxuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XHJcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuXHJcbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcclxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcclxuICAgIH1cclxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XHJcbiAgfVxyXG5cclxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xyXG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XHJcblxyXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xyXG4gIHZtLiRyZWZzID0ge307XHJcblxyXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcclxuICB2bS5faW5hY3RpdmUgPSBudWxsO1xyXG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xyXG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcclxuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcclxuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XHJcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xyXG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfVxyXG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcclxuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XHJcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xyXG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XHJcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcclxuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxyXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcclxuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxyXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcclxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxyXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cclxuICAgICAgKTtcclxuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXHJcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXHJcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHVwZGF0ZXNcclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XHJcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcclxuICAgIGlmIChwcmV2RWwpIHtcclxuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxyXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcclxuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XHJcbiAgICB9XHJcbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXHJcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxyXG4gIH07XHJcblxyXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZtID0gdGhpcztcclxuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xyXG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcclxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xyXG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xyXG4gICAgfVxyXG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcclxuICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cclxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcclxuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcclxuICAgIH1cclxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxyXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxyXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XHJcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXHJcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xyXG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cclxuICAgIHZtLiRvZmYoKTtcclxuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxyXG4gICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXHJcbiAgICBpZiAodm0uJHZub2RlKSB7XHJcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcclxuICB2bSxcclxuICBlbCxcclxuICBoeWRyYXRpbmdcclxuKSB7XHJcbiAgdm0uJGVsID0gZWw7XHJcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxyXG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcclxuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xyXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcclxuXHJcbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcclxuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcclxuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xyXG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcclxuXHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XHJcbiAgICAgIG1hcmsoZW5kVGFnKTtcclxuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcclxuXHJcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xyXG4gICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcclxuICBoeWRyYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcclxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xyXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xyXG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcclxuICB9XHJcbiAgcmV0dXJuIHZtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcclxuICB2bSxcclxuICBwcm9wc0RhdGEsXHJcbiAgbGlzdGVuZXJzLFxyXG4gIHBhcmVudFZub2RlLFxyXG4gIHJlbmRlckNoaWxkcmVuXHJcbikge1xyXG4gIHtcclxuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cclxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxyXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxyXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xyXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xyXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xyXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xyXG4gICk7XHJcblxyXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXHJcblxyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcclxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcclxuICB9XHJcbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XHJcblxyXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxyXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxyXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXHJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XHJcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcclxuXHJcbiAgLy8gdXBkYXRlIHByb3BzXHJcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xyXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XHJcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XHJcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcclxuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgIH1cclxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XHJcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXHJcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXHJcbiAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XHJcbiAgfVxyXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXHJcbiAgaWYgKGhhc0NoaWxkcmVuKSB7XHJcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xyXG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICB7XHJcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XHJcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XHJcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcclxuICBpZiAoZGlyZWN0KSB7XHJcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XHJcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcclxuICBpZiAoZGlyZWN0KSB7XHJcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xyXG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xyXG4gICAgfVxyXG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XHJcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XHJcbiAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcclxuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuXHJcbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xyXG5cclxudmFyIHF1ZXVlID0gW107XHJcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xyXG52YXIgaGFzID0ge307XHJcbnZhciBjaXJjdWxhciA9IHt9O1xyXG52YXIgd2FpdGluZyA9IGZhbHNlO1xyXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcclxudmFyIGluZGV4ID0gMDtcclxuXHJcbi8qKlxyXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcclxuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgaGFzID0ge307XHJcbiAge1xyXG4gICAgY2lyY3VsYXIgPSB7fTtcclxuICB9XHJcbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xyXG4gIGZsdXNoaW5nID0gdHJ1ZTtcclxuICB2YXIgd2F0Y2hlciwgaWQ7XHJcblxyXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXHJcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxyXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcclxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxyXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cclxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XHJcblxyXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxyXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xyXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcclxuICAgIGlkID0gd2F0Y2hlci5pZDtcclxuICAgIGhhc1tpZF0gPSBudWxsO1xyXG4gICAgd2F0Y2hlci5ydW4oKTtcclxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcclxuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XHJcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcclxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXHJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxyXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICB3YXRjaGVyLnZtXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXHJcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcclxuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcclxuXHJcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xyXG5cclxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcclxuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xyXG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcclxuXHJcbiAgLy8gZGV2dG9vbCBob29rXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xyXG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XHJcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcclxuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XHJcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xyXG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXHJcbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xyXG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cclxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxyXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xyXG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcclxuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cclxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXHJcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XHJcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcclxuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XHJcbiAgICBoYXNbaWRdID0gdHJ1ZTtcclxuICAgIGlmICghZmx1c2hpbmcpIHtcclxuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcclxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cclxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xyXG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXHJcbiAgICBpZiAoIXdhaXRpbmcpIHtcclxuICAgICAgd2FpdGluZyA9IHRydWU7XHJcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgdWlkJDIgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxyXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cclxuICovXHJcbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXHJcbiAgdm0sXHJcbiAgZXhwT3JGbixcclxuICBjYixcclxuICBvcHRpb25zXHJcbikge1xyXG4gIHRoaXMudm0gPSB2bTtcclxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcclxuICAvLyBvcHRpb25zXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xyXG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XHJcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcclxuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcclxuICB9XHJcbiAgdGhpcy5jYiA9IGNiO1xyXG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXHJcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXHJcbiAgdGhpcy5kZXBzID0gW107XHJcbiAgdGhpcy5uZXdEZXBzID0gW107XHJcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xyXG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcclxuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XHJcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXHJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xyXG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xyXG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xyXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXHJcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcclxuICAgICAgICB2bVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XHJcbiAgICA/IHVuZGVmaW5lZFxyXG4gICAgOiB0aGlzLmdldCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgcHVzaFRhcmdldCh0aGlzKTtcclxuICB2YXIgdmFsdWU7XHJcbiAgdmFyIHZtID0gdGhpcy52bTtcclxuICB0cnkge1xyXG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IGVcclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXHJcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcclxuICAgIGlmICh0aGlzLmRlZXApIHtcclxuICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcG9wVGFyZ2V0KCk7XHJcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xyXG4gIHZhciBpZCA9IGRlcC5pZDtcclxuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcclxuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XHJcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xyXG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XHJcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xyXG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XHJcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xyXG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XHJcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XHJcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcclxuICB0bXAgPSB0aGlzLmRlcHM7XHJcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xyXG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcclxuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAodGhpcy5sYXp5KSB7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xyXG4gICAgdGhpcy5ydW4oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cclxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cclxuICovXHJcbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XHJcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xyXG4gICAgaWYgKFxyXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxyXG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cclxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxyXG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXHJcbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgICB0aGlzLmRlZXBcclxuICAgICkge1xyXG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXHJcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgaWYgKHRoaXMudXNlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cclxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XHJcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxyXG4gKi9cclxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XHJcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuXHJcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XHJcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XHJcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxyXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XHJcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgZ2V0OiBub29wLFxyXG4gIHNldDogbm9vcFxyXG59O1xyXG5cclxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXHJcbiAgfTtcclxuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xyXG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XHJcbiAgfTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcclxuICB2bS5fd2F0Y2hlcnMgPSBbXTtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xyXG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cclxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XHJcbiAgaWYgKG9wdHMuZGF0YSkge1xyXG4gICAgaW5pdERhdGEodm0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XHJcbiAgfVxyXG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cclxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xyXG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xyXG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XHJcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XHJcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcclxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cclxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xyXG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcclxuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XHJcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcclxuICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XHJcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xyXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xyXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxyXG4gICAgICAgICAgICB2bVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxyXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcclxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cclxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcclxuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XHJcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XHJcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xyXG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXHJcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXHJcbiAgICA6IGRhdGEgfHwge307XHJcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XHJcbiAgICBkYXRhID0ge307XHJcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXHJcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxyXG4gICAgICB2bVxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XHJcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xyXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICB7XHJcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXHJcbiAgICAgICAgICB2bVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xyXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcclxuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gb2JzZXJ2ZSBkYXRhXHJcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XHJcbiAgICByZXR1cm4ge31cclxuICB9XHJcbn1cclxuXHJcbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XHJcblxyXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xyXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxyXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xyXG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xyXG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXHJcbiAgICAgICAgdm1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzU1NSKSB7XHJcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXHJcbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcclxuICAgICAgICB2bSxcclxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcclxuICAgICAgICBub29wLFxyXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXHJcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxyXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxyXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xyXG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcclxuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XHJcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcclxuICB0YXJnZXQsXHJcbiAga2V5LFxyXG4gIHVzZXJEZWZcclxuKSB7XHJcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XHJcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcclxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgIDogdXNlckRlZjtcclxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcclxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxyXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxyXG4gICAgICAgIDogdXNlckRlZi5nZXRcclxuICAgICAgOiBub29wO1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XHJcbiAgICAgID8gdXNlckRlZi5zZXRcclxuICAgICAgOiBub29wO1xyXG4gIH1cclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xyXG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcclxuICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XHJcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgIHtcclxuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xyXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXHJcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XHJcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXHJcbiAgdm0sXHJcbiAga2V5T3JGbixcclxuICBoYW5kbGVyLFxyXG4gIG9wdGlvbnNcclxuKSB7XHJcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcclxuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xyXG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xyXG4gIH1cclxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xyXG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxyXG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxyXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cclxuICB2YXIgZGF0YURlZiA9IHt9O1xyXG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xyXG4gIHZhciBwcm9wc0RlZiA9IHt9O1xyXG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XHJcbiAge1xyXG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXHJcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xyXG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXHJcbiAgICBleHBPckZuLFxyXG4gICAgY2IsXHJcbiAgICBvcHRpb25zXHJcbiAgKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcclxuICAgIH1cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcclxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcclxuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xyXG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xyXG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcclxuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgaWYgKHByb3ZpZGUpIHtcclxuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxyXG4gICAgICA6IHByb3ZpZGU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcclxuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICBpZiAocmVzdWx0KSB7XHJcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcclxuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgIHtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcclxuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcclxuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXHJcbiAgICAgICAgICAgIHZtXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XHJcbiAgaWYgKGluamVjdCkge1xyXG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcclxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcclxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcclxuICAgICAgICB9KVxyXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcclxuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xyXG4gICAgICB3aGlsZSAoc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XHJcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcclxuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XHJcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXHJcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcclxuICB2YWwsXHJcbiAgcmVuZGVyXHJcbikge1xyXG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xyXG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGlzRGVmKHJldCkpIHtcclxuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXHJcbiAgbmFtZSxcclxuICBmYWxsYmFjayxcclxuICBwcm9wcyxcclxuICBiaW5kT2JqZWN0XHJcbikge1xyXG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcclxuICB2YXIgbm9kZXM7XHJcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxyXG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICAgIGlmIChiaW5kT2JqZWN0KSB7XHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxyXG4gICAgICAgICAgdGhpc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XHJcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXHJcbiAgICBpZiAoc2xvdE5vZGVzKSB7XHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90Tm9kZXMuX3JlbmRlcmVkKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXHJcbiAgICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxyXG4gICAgICAgICAgdGhpc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBub2RlcyA9IHNsb3ROb2RlcyB8fCBmYWxsYmFjaztcclxuICB9XHJcblxyXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xyXG4gIGlmICh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbm9kZXNcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcclxuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cclxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXHJcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXHJcbiAgZXZlbnRLZXlDb2RlLFxyXG4gIGtleSxcclxuICBidWlsdEluQWxpYXMsXHJcbiAgZXZlbnRLZXlOYW1lXHJcbikge1xyXG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcclxuICBpZiAoa2V5Q29kZXMpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xyXG4gICAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xyXG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxyXG4gIGRhdGEsXHJcbiAgdGFnLFxyXG4gIHZhbHVlLFxyXG4gIGFzUHJvcCxcclxuICBpc1N5bmNcclxuKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxyXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGhhc2g7XHJcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XHJcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcclxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaGFzaCA9IGRhdGE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XHJcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcclxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXHJcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XHJcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xyXG5cclxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcclxuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXHJcbiAgaW5kZXgsXHJcbiAgaXNJbkZvcixcclxuICBpc09uY2VcclxuKSB7XHJcbiAgLy8gcmVuZGVyIGZucyBnZW5lcmF0ZWQgYnkgY29tcGlsZXIgPCAyLjUuNCBkb2VzIG5vdCBwcm92aWRlIHYtb25jZVxyXG4gIC8vIGluZm9ybWF0aW9uIHRvIHJ1bnRpbWUgc28gYmUgY29uc2VydmF0aXZlXHJcbiAgdmFyIGlzT2xkVmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xyXG4gIC8vIGlmIGEgc3RhdGljIHRyZWUgaXMgZ2VuZXJhdGVkIGJ5IHYtb25jZSwgaXQgaXMgY2FjaGVkIG9uIHRoZSBpbnN0YW5jZTtcclxuICAvLyBvdGhlcndpc2UgaXQgaXMgcHVyZWx5IHN0YXRpYyBhbmQgY2FuIGJlIGNhY2hlZCBvbiB0aGUgc2hhcmVkIG9wdGlvbnNcclxuICAvLyBhY3Jvc3MgYWxsIGluc3RhbmNlcy5cclxuICB2YXIgcmVuZGVyRm5zID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgdmFyIGNhY2hlZCA9IGlzT2xkVmVyc2lvbiB8fCBpc09uY2VcclxuICAgID8gKHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKSlcclxuICAgIDogKHJlbmRlckZucy5jYWNoZWQgfHwgKHJlbmRlckZucy5jYWNoZWQgPSBbXSkpO1xyXG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcclxuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcclxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXHJcbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXHJcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcclxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXHJcbiAgfVxyXG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cclxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHJlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSwgbnVsbCwgdGhpcyk7XHJcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcclxuICByZXR1cm4gdHJlZVxyXG59XHJcblxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cclxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrT25jZSAoXHJcbiAgdHJlZSxcclxuICBpbmRleCxcclxuICBrZXlcclxuKSB7XHJcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIHRyZWVcclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXHJcbiAgdHJlZSxcclxuICBrZXksXHJcbiAgaXNPbmNlXHJcbikge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XHJcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XHJcbiAgbm9kZS5rZXkgPSBrZXk7XHJcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcclxuICBpZiAodmFsdWUpIHtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcclxuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XHJcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XHJcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XHJcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XHJcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcclxuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xyXG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XHJcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xyXG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcclxuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xyXG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XHJcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xyXG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcclxuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xyXG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcclxuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcclxuICBkYXRhLFxyXG4gIHByb3BzLFxyXG4gIGNoaWxkcmVuLFxyXG4gIHBhcmVudCxcclxuICBDdG9yXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XHJcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcclxuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xyXG5cclxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXHJcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xyXG4gIHZhciBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XHJcbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xyXG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xyXG5cclxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgaWYgKGlzQ29tcGlsZWQpIHtcclxuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxyXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXHJcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcclxuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcclxuICB9XHJcblxyXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XHJcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcclxuICAgICAgaWYgKHZub2RlKSB7XHJcbiAgICAgICAgdm5vZGUuZnVuY3Rpb25hbFNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xyXG4gICAgICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2bm9kZVxyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xyXG4gIH1cclxufVxyXG5cclxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxyXG4gIEN0b3IsXHJcbiAgcHJvcHNEYXRhLFxyXG4gIGRhdGEsXHJcbiAgY29udGV4dFZtLFxyXG4gIGNoaWxkcmVuXHJcbikge1xyXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xyXG4gIHZhciBwcm9wcyA9IHt9O1xyXG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XHJcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XHJcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XHJcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cclxuICB9XHJcblxyXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxyXG4gICAgZGF0YSxcclxuICAgIHByb3BzLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBjb250ZXh0Vm0sXHJcbiAgICBDdG9yXHJcbiAgKTtcclxuXHJcbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcclxuXHJcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dFZtO1xyXG4gICAgdm5vZGUuZnVuY3Rpb25hbE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgaWYgKGRhdGEuc2xvdCkge1xyXG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB2bm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xyXG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxyXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcclxuICBpbml0OiBmdW5jdGlvbiBpbml0IChcclxuICAgIHZub2RlLFxyXG4gICAgaHlkcmF0aW5nLFxyXG4gICAgcGFyZW50RWxtLFxyXG4gICAgcmVmRWxtXHJcbiAgKSB7XHJcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXHJcbiAgICAgICAgcGFyZW50RWxtLFxyXG4gICAgICAgIHJlZkVsbVxyXG4gICAgICApO1xyXG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xyXG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcclxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXHJcbiAgICAgIGNoaWxkLFxyXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xyXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcclxuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcclxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cclxuICAgICk7XHJcbiAgfSxcclxuXHJcbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XHJcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xyXG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcclxuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xyXG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcclxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcclxuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXHJcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxyXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xyXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XHJcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXHJcbiAgQ3RvcixcclxuICBkYXRhLFxyXG4gIGNvbnRleHQsXHJcbiAgY2hpbGRyZW4sXHJcbiAgdGFnXHJcbikge1xyXG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XHJcblxyXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxyXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xyXG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcclxuICB9XHJcblxyXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcclxuICAvLyByZWplY3QuXHJcbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB7XHJcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvLyBhc3luYyBjb21wb25lbnRcclxuICB2YXIgYXN5bmNGYWN0b3J5O1xyXG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xyXG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcclxuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XHJcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcclxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXHJcbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cclxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXHJcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICB0YWdcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGF0YSA9IGRhdGEgfHwge307XHJcblxyXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cclxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xyXG5cclxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXHJcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XHJcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLy8gZXh0cmFjdCBwcm9wc1xyXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XHJcblxyXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcclxuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXHJcbiAgfVxyXG5cclxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xyXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXHJcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XHJcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcclxuXHJcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XHJcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXHJcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxyXG5cclxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xyXG4gICAgZGF0YSA9IHt9O1xyXG4gICAgaWYgKHNsb3QpIHtcclxuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcclxuICBtZXJnZUhvb2tzKGRhdGEpO1xyXG5cclxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxyXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xyXG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcclxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXHJcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxyXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcclxuICAgIGFzeW5jRmFjdG9yeVxyXG4gICk7XHJcbiAgcmV0dXJuIHZub2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxyXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcclxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxyXG4gIHBhcmVudEVsbSxcclxuICByZWZFbG1cclxuKSB7XHJcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXHJcbiAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcclxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXHJcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxyXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcclxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxyXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXHJcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxyXG4gIH07XHJcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcclxuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xyXG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcclxuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xyXG4gIGlmICghZGF0YS5ob29rKSB7XHJcbiAgICBkYXRhLmhvb2sgPSB7fTtcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XHJcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xyXG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XHJcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgIG9uZShhLCBiLCBjLCBkKTtcclxuICAgIHR3byhhLCBiLCBjLCBkKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cclxuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XHJcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XHJcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xyXG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XHJcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcclxuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xyXG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XHJcblxyXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxyXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZSxcclxuICBhbHdheXNOb3JtYWxpemVcclxuKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XHJcbiAgICBjaGlsZHJlbiA9IGRhdGE7XHJcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcclxuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcclxuICB9XHJcbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXHJcbiAgY29udGV4dCxcclxuICB0YWcsXHJcbiAgZGF0YSxcclxuICBjaGlsZHJlbixcclxuICBub3JtYWxpemF0aW9uVHlwZVxyXG4pIHtcclxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXHJcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxyXG4gICAgICBjb250ZXh0XHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxyXG4gIH1cclxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxyXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xyXG4gICAgdGFnID0gZGF0YS5pcztcclxuICB9XHJcbiAgaWYgKCF0YWcpIHtcclxuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcclxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcclxuICB9XHJcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxyXG4gICkge1xyXG4gICAgd2FybihcclxuICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcclxuICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcclxuICAgICAgY29udGV4dFxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxyXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxyXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXHJcbiAgKSB7XHJcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcclxuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XHJcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gIH1cclxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcclxuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcclxuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gIH1cclxuICB2YXIgdm5vZGUsIG5zO1xyXG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIEN0b3I7XHJcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcclxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXHJcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxyXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xyXG4gICAgICAvLyBjb21wb25lbnRcclxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcclxuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcclxuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cclxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXHJcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcclxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxyXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XHJcbiAgfVxyXG4gIGlmIChpc0RlZih2bm9kZSkpIHtcclxuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cclxuICAgIHJldHVybiB2bm9kZVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XHJcbiAgdm5vZGUubnMgPSBucztcclxuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcclxuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxyXG4gICAgbnMgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3JjZSA9IHRydWU7XHJcbiAgfVxyXG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcclxuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XHJcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcclxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXHJcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcclxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XHJcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcclxuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcclxuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcclxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxyXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcclxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xyXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcclxuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cclxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cclxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcclxuXHJcbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cclxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXHJcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIHtcclxuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XHJcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcclxuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcclxuXHJcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcclxuICB9O1xyXG5cclxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xyXG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XHJcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcclxuXHJcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xyXG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxyXG4gICAgICAvLyBsYXN0IHJlbmRlci4gVGhleSBuZWVkIHRvIGJlIGNsb25lZCB0byBlbnN1cmUgXCJmcmVzaG5lc3NcIiBmb3IgdGhpcyByZW5kZXIuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xyXG4gICAgICAgIC8vIF9yZW5kZXJlZCBpcyBhIGZsYWcgYWRkZWQgYnkgcmVuZGVyU2xvdCwgYnV0IG1heSBub3QgYmUgcHJlc2VudFxyXG4gICAgICAgIC8vIGlmIHRoZSBzbG90IGlzIHBhc3NlZCBmcm9tIG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcclxuICAgICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXMoc2xvdCwgdHJ1ZSAvKiBkZWVwICovKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcclxuXHJcbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXHJcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cclxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcclxuICAgIC8vIHJlbmRlciBzZWxmXHJcbiAgICB2YXIgdm5vZGU7XHJcbiAgICB0cnkge1xyXG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XHJcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxyXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICB7XHJcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XHJcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xyXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0IHBhcmVudFxyXG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xyXG4gICAgcmV0dXJuIHZub2RlXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgdWlkJDEgPSAwO1xyXG5cclxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcclxuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAvLyBhIHVpZFxyXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XHJcblxyXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XHJcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xyXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxyXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcclxuICAgIC8vIG1lcmdlIG9wdGlvbnNcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XHJcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXHJcbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcclxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXHJcbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcclxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcclxuICAgICAgICBvcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIHZtXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAge1xyXG4gICAgICBpbml0UHJveHkodm0pO1xyXG4gICAgfVxyXG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxyXG4gICAgdm0uX3NlbGYgPSB2bTtcclxuICAgIGluaXRMaWZlY3ljbGUodm0pO1xyXG4gICAgaW5pdEV2ZW50cyh2bSk7XHJcbiAgICBpbml0UmVuZGVyKHZtKTtcclxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XHJcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xyXG4gICAgaW5pdFN0YXRlKHZtKTtcclxuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcclxuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xyXG4gICAgICBtYXJrKGVuZFRhZyk7XHJcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xyXG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcclxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcclxuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxyXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcclxuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xyXG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcclxuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xyXG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcclxuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XHJcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xyXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xyXG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcclxuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcclxuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xyXG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xyXG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XHJcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxyXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXHJcbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xyXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXHJcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xyXG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xyXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcclxuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xyXG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb3B0aW9uc1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XHJcbiAgdmFyIG1vZGlmaWVkO1xyXG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XHJcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xyXG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XHJcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xyXG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xyXG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cclxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbW9kaWZpZWRcclxufVxyXG5cclxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcclxuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxyXG4gIC8vIGJldHdlZW4gbWVyZ2VzXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XHJcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcclxuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XHJcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbGF0ZXN0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXHJcbiAgKSB7XHJcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XHJcbiAgfVxyXG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbn1cclxuXHJcbmluaXRNaXhpbihWdWUkMyk7XHJcbnN0YXRlTWl4aW4oVnVlJDMpO1xyXG5ldmVudHNNaXhpbihWdWUkMyk7XHJcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcclxucmVuZGVyTWl4aW4oVnVlJDMpO1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcclxuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xyXG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XHJcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xyXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XHJcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XHJcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH07XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xyXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xyXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9O1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xyXG4gIC8qKlxyXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxyXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcclxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cclxuICAgKi9cclxuICBWdWUuY2lkID0gMDtcclxuICB2YXIgY2lkID0gMTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcclxuICAgKi9cclxuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcclxuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIFN1cGVyID0gdGhpcztcclxuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xyXG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcclxuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xyXG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XHJcbiAgICB7XHJcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgd2FybihcclxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXHJcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXHJcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xyXG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgIFN1Yi5jaWQgPSBjaWQrKztcclxuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxyXG4gICAgICBTdXBlci5vcHRpb25zLFxyXG4gICAgICBleHRlbmRPcHRpb25zXHJcbiAgICApO1xyXG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcblxyXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cclxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXHJcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXHJcbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcclxuICAgIH1cclxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxyXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcclxuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXHJcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xyXG4gICAgfSk7XHJcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXHJcbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxyXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxyXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XHJcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XHJcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXHJcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcclxuICAgIHJldHVybiBTdWJcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xyXG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcclxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcclxuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XHJcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxyXG4gICAgICBpZCxcclxuICAgICAgZGVmaW5pdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xyXG4gICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XHJcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XHJcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XHJcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXHJcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xyXG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XHJcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XHJcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xyXG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XHJcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XHJcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XHJcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcclxuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xyXG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxyXG4gIGNhY2hlLFxyXG4gIGtleSxcclxuICBrZXlzLFxyXG4gIGN1cnJlbnRcclxuKSB7XHJcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XHJcbiAgaWYgKGNhY2hlZCQkMSAmJiBjYWNoZWQkJDEgIT09IGN1cnJlbnQpIHtcclxuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xyXG4gIH1cclxuICBjYWNoZVtrZXldID0gbnVsbDtcclxuICByZW1vdmUoa2V5cywga2V5KTtcclxufVxyXG5cclxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xyXG5cclxudmFyIEtlZXBBbGl2ZSA9IHtcclxuICBuYW1lOiAna2VlcC1hbGl2ZScsXHJcbiAgYWJzdHJhY3Q6IHRydWUsXHJcblxyXG4gIHByb3BzOiB7XHJcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICB9LFxyXG5cclxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcclxuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdGhpcy5rZXlzID0gW107XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xyXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xyXG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB3YXRjaDoge1xyXG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XHJcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XHJcbiAgICB9LFxyXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XHJcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcclxuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcclxuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XHJcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcclxuICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XHJcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcclxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgIC8vIGV4Y2x1ZGVkXHJcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gdm5vZGVcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcclxuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XHJcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcclxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXHJcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcclxuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXHJcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXHJcbiAgICAgICAgOiB2bm9kZS5rZXk7XHJcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcclxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcclxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxyXG4gIH1cclxufTtcclxuXHJcbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcclxuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcclxuICAvLyBjb25maWdcclxuICB2YXIgY29uZmlnRGVmID0ge307XHJcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcclxuICB7XHJcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xyXG5cclxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cclxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cclxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxyXG4gIFZ1ZS51dGlsID0ge1xyXG4gICAgd2Fybjogd2FybixcclxuICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXHJcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcclxuICB9O1xyXG5cclxuICBWdWUuc2V0ID0gc2V0O1xyXG4gIFZ1ZS5kZWxldGUgPSBkZWw7XHJcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XHJcblxyXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcclxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cclxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcclxuXHJcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcclxuXHJcbiAgaW5pdFVzZShWdWUpO1xyXG4gIGluaXRNaXhpbiQxKFZ1ZSk7XHJcbiAgaW5pdEV4dGVuZChWdWUpO1xyXG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xyXG59XHJcblxyXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XHJcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcclxuICB9XHJcbn0pO1xyXG5cclxuVnVlJDMudmVyc2lvbiA9ICcyLjUuOCc7XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxyXG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cclxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcclxuXHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XHJcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxyXG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XHJcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXHJcbiAgKVxyXG59O1xyXG5cclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxuXHJcbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcclxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcclxuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xyXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xyXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xyXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xyXG4pO1xyXG5cclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcblxyXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xyXG59O1xyXG5cclxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXHJcbn07XHJcblxyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xyXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xyXG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXHJcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXHJcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXHJcbiAgICAgIDogcGFyZW50LmNsYXNzXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXHJcbiAgc3RhdGljQ2xhc3MsXHJcbiAgZHluYW1pY0NsYXNzXHJcbikge1xyXG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xyXG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXHJcbiAgfVxyXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICB9XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIHZhciBzdHJpbmdpZmllZDtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlW2tleV0pIHtcclxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XHJcbiAgICAgIHJlcyArPSBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgbmFtZXNwYWNlTWFwID0ge1xyXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcclxufTtcclxuXHJcbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxyXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcclxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xyXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcclxuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xyXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcclxuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXHJcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xyXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xyXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xyXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXHJcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXHJcbik7XHJcblxyXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcclxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cclxudmFyIGlzU1ZHID0gbWFrZU1hcChcclxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xyXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcclxuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXHJcbiAgdHJ1ZVxyXG4pO1xyXG5cclxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcclxuXHJcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xyXG4gIGlmIChpc1NWRyh0YWcpKSB7XHJcbiAgICByZXR1cm4gJ3N2ZydcclxuICB9XHJcbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXHJcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xyXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgcmV0dXJuICdtYXRoJ1xyXG4gIH1cclxufVxyXG5cclxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoIWluQnJvd3Nlcikge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxyXG4gIH1cclxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxyXG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XHJcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcclxuICAgICkpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcclxuICB9XHJcbn1cclxuXHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xyXG5cclxuLyogICovXHJcblxyXG4vKipcclxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcclxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICBpZiAoIXNlbGVjdGVkKSB7XHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXHJcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3RlZFxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZWxcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xyXG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xyXG4gICAgcmV0dXJuIGVsbVxyXG4gIH1cclxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxyXG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xyXG4gIH1cclxuICByZXR1cm4gZWxtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcclxuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XHJcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcclxufVxyXG5cclxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xyXG4gIHJldHVybiBub2RlLnRhZ05hbWVcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcclxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xyXG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcclxufVxyXG5cclxuXHJcbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXHJcbiAgICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcclxuICAgIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcclxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXHJcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcclxuICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcclxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcclxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXHJcbiAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXHJcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxyXG4gICAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxyXG4gICAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcclxufSk7XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciByZWYgPSB7XHJcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XHJcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgfSxcclxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XHJcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcclxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcclxuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xyXG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcclxuICBpZiAoIWtleSkgeyByZXR1cm4gfVxyXG5cclxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xyXG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XHJcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcclxuICBpZiAoaXNSZW1vdmFsKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XHJcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XHJcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XHJcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcclxuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcclxuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xyXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcclxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiAqXHJcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxyXG4gKlxyXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XHJcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxyXG4gKi9cclxuXHJcbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XHJcblxyXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcclxuXHJcbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xyXG4gIHJldHVybiAoXHJcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxyXG4gICAgICAoXHJcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXHJcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXHJcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxyXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcclxuICAgICAgKSB8fCAoXHJcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxyXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxyXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXHJcbiAgICAgIClcclxuICAgIClcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcclxuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxyXG4gIHZhciBpO1xyXG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XHJcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcclxuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcclxuICB2YXIgaSwga2V5O1xyXG4gIHZhciBtYXAgPSB7fTtcclxuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xyXG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xyXG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XHJcbiAgfVxyXG4gIHJldHVybiBtYXBcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xyXG4gIHZhciBpLCBqO1xyXG4gIHZhciBjYnMgPSB7fTtcclxuXHJcbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XHJcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xyXG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcclxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XHJcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcclxuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcclxuICAgIHJldHVybiByZW1vdmVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcclxuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxyXG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICFpblZQcmUgJiZcclxuICAgICAgIXZub2RlLm5zICYmXHJcbiAgICAgICEoXHJcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcclxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcclxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXHJcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcclxuICAgICAgICB9KVxyXG4gICAgICApICYmXHJcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcclxuICAgIClcclxuICB9XHJcblxyXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XHJcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XHJcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xyXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xyXG4gICAgaWYgKGlzRGVmKHRhZykpIHtcclxuICAgICAge1xyXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XHJcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XHJcbiAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXHJcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcclxuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcclxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcclxuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXHJcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XHJcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcclxuXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICB7XHJcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcclxuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XHJcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcclxuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcclxuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxyXG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcclxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXHJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXHJcbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xyXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XHJcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XHJcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICBzZXRTY29wZSh2bm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cclxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxyXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXHJcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcclxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxyXG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcclxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xyXG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcclxuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcclxuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxyXG4gICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcclxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXHJcbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZnVuY3Rpb25hbFNjb3BlSWQpKSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XHJcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cclxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXHJcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcclxuICAgICAgaSAhPT0gdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgJiZcclxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXHJcbiAgICApIHtcclxuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xyXG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcclxuICAgIHZhciBpLCBqO1xyXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcclxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcclxuICAgICAgaWYgKGlzRGVmKGNoKSkge1xyXG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XHJcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcclxuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcclxuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcclxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xyXG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcclxuICAgICAgaWYgKGlzRGVmKHJtKSkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xyXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcclxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXHJcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcclxuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xyXG4gICAgICAgIGkodm5vZGUsIHJtKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBybSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xyXG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcclxuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XHJcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcclxuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XHJcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xyXG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xyXG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcclxuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XHJcblxyXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XHJcbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXHJcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xyXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcclxuXHJcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xyXG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xyXG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxyXG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XHJcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XHJcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcclxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XHJcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xyXG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxyXG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xyXG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cclxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxyXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cclxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcclxuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcclxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICF2bm9kZVRvTW92ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXHJcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XHJcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcclxuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcclxuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcclxuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xyXG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xyXG5cclxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xyXG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cclxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxyXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXHJcbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxyXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcclxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxyXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxyXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcclxuICAgICkge1xyXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcclxuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xyXG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgIH1cclxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XHJcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xyXG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XHJcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XHJcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XHJcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XHJcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xyXG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXHJcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxyXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xyXG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XHJcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcclxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cclxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xyXG5cclxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxyXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XHJcbiAgICB2bm9kZS5lbG0gPSBlbG07XHJcblxyXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcclxuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXHJcbiAgICB7XHJcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cclxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cclxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0RlZih0YWcpKSB7XHJcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcclxuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXHJcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xyXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xyXG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XHJcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xyXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XHJcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcclxuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XHJcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcclxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxyXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xyXG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcclxuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcclxuXHJcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcclxuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxyXG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XHJcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcclxuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XHJcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXHJcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcclxuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxyXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cclxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XHJcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XHJcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcclxuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XHJcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcclxuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXHJcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xyXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cclxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XHJcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XHJcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcclxuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXHJcbiAgICAgICAgY3JlYXRlRWxtKFxyXG4gICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXHJcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxyXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXHJcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxyXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxyXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcclxuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XHJcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XHJcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcclxuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gIzY1MTNcclxuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxyXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cclxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcclxuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XHJcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xyXG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xyXG4gICAgcmV0dXJuIHZub2RlLmVsbVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgZGlyZWN0aXZlcyA9IHtcclxuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XHJcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XHJcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xyXG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XHJcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcclxuXHJcbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XHJcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XHJcblxyXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xyXG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcclxuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcclxuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgIGlmICghb2xkRGlyKSB7XHJcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcclxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcclxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xyXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XHJcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XHJcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XHJcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcclxuICBkaXJzLFxyXG4gIHZtXHJcbikge1xyXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGlmICghZGlycykge1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICB2YXIgaSwgZGlyO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XHJcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcclxuICAgIH1cclxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XHJcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xyXG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcclxuICBpZiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBiYXNlTW9kdWxlcyA9IFtcclxuICByZWYsXHJcbiAgZGlyZWN0aXZlc1xyXG5dO1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBrZXksIGN1ciwgb2xkO1xyXG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XHJcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcclxuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxyXG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XHJcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcclxuICB9XHJcblxyXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICBjdXIgPSBhdHRyc1trZXldO1xyXG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcclxuICAgIGlmIChvbGQgIT09IGN1cikge1xyXG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxyXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoKGlzSUU5IHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XHJcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xyXG4gIH1cclxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xyXG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcclxuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xyXG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xyXG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcclxuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XHJcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxyXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cclxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcclxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcclxuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcclxuICAgICAgICA/ICd0cnVlJ1xyXG4gICAgICAgIDoga2V5O1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XHJcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcclxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XHJcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGF0dHJzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXHJcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xyXG59O1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XHJcbiAgaWYgKFxyXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxyXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXHJcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcclxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXHJcbiAgICAgIClcclxuICAgIClcclxuICApIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xyXG5cclxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXHJcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcclxuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xyXG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgdGhlIGNsYXNzXHJcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XHJcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGtsYXNzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXHJcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XHJcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XHJcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xyXG4gIHZhciBjdXJseSA9IDA7XHJcbiAgdmFyIHNxdWFyZSA9IDA7XHJcbiAgdmFyIHBhcmVuID0gMDtcclxuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcclxuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xyXG4gICAgcHJldiA9IGM7XHJcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XHJcbiAgICBpZiAoaW5TaW5nbGUpIHtcclxuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XHJcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XHJcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxyXG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XHJcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XHJcbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcclxuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxyXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcclxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXHJcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxyXG4gICAgKSB7XHJcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXHJcbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxyXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcclxuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXHJcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxyXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcclxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXHJcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxyXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xyXG4gICAgICAgIHZhciBqID0gaSAtIDE7XHJcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcclxuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XHJcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcclxuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcclxuICAgIHB1c2hGaWx0ZXIoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xyXG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcclxuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZpbHRlcnMpIHtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV4cHJlc3Npb25cclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcclxuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XHJcbiAgaWYgKGkgPCAwKSB7XHJcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XHJcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XHJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcclxuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcclxuICBtb2R1bGVzLFxyXG4gIGtleVxyXG4pIHtcclxuICByZXR1cm4gbW9kdWxlc1xyXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXHJcbiAgICA6IFtdXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xyXG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xyXG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXHJcbiAgZWwsXHJcbiAgbmFtZSxcclxuICByYXdOYW1lLFxyXG4gIHZhbHVlLFxyXG4gIGFyZyxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXHJcbiAgZWwsXHJcbiAgbmFtZSxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnMsXHJcbiAgaW1wb3J0YW50LFxyXG4gIHdhcm5cclxuKSB7XHJcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xyXG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChcclxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcclxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXHJcbiAgKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xyXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXHJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XHJcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcclxuICB9XHJcbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XHJcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxyXG4gIH1cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcclxuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcclxuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXHJcbiAgfVxyXG5cclxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcclxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxyXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxyXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XHJcbiAgICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XHJcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xyXG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xyXG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XHJcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnRzO1xyXG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XHJcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcclxuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcclxuICB9XHJcblxyXG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUgfTtcclxuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xyXG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XHJcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcclxuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcclxuICB9IGVsc2Uge1xyXG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcclxuICBlbCxcclxuICBuYW1lLFxyXG4gIGdldFN0YXRpY1xyXG4pIHtcclxuICB2YXIgZHluYW1pY1ZhbHVlID1cclxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XHJcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcclxuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcclxuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxyXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xyXG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XHJcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XHJcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXHJcbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xyXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXHJcbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxyXG4gIGVsLFxyXG4gIG5hbWUsXHJcbiAgcmVtb3ZlRnJvbU1hcFxyXG4pIHtcclxuICB2YXIgdmFsO1xyXG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcclxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xyXG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xyXG4gIH1cclxuICByZXR1cm4gdmFsXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLyoqXHJcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcclxuICovXHJcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcclxuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcclxuICB2YXIgdHJpbSA9IHJlZi50cmltO1xyXG5cclxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xyXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xyXG4gIGlmICh0cmltKSB7XHJcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxyXG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xyXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXHJcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuICBpZiAobnVtYmVyKSB7XHJcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XHJcbiAgfVxyXG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XHJcblxyXG4gIGVsLm1vZGVsID0ge1xyXG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxyXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXHJcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxyXG4gIHZhbHVlLFxyXG4gIGFzc2lnbm1lbnRcclxuKSB7XHJcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xyXG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxyXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cclxuICpcclxuICogUG9zc2libGUgY2FzZXM6XHJcbiAqXHJcbiAqIC0gdGVzdFxyXG4gKiAtIHRlc3Rba2V5XVxyXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cclxuICogLSB0ZXN0W1wiYVwiXVtrZXldXHJcbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxyXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cclxuICpcclxuICovXHJcblxyXG52YXIgbGVuO1xyXG52YXIgc3RyO1xyXG52YXIgY2hyO1xyXG52YXIgaW5kZXgkMTtcclxudmFyIGV4cHJlc3Npb25Qb3M7XHJcbnZhciBleHByZXNzaW9uRW5kUG9zO1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcclxuICBsZW4gPSB2YWwubGVuZ3RoO1xyXG5cclxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XHJcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXHJcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleHA6IHZhbCxcclxuICAgICAgICBrZXk6IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RyID0gdmFsO1xyXG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XHJcblxyXG4gIHdoaWxlICghZW9mKCkpIHtcclxuICAgIGNociA9IG5leHQoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcclxuICAgICAgcGFyc2VCcmFja2V0KGNocik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXHJcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHQgKCkge1xyXG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVvZiAoKSB7XHJcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xyXG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XHJcbiAgdmFyIGluQnJhY2tldCA9IDE7XHJcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xyXG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxyXG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxyXG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xyXG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcclxuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XHJcbiAgd2hpbGUgKCFlb2YoKSkge1xyXG4gICAgY2hyID0gbmV4dCgpO1xyXG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIHdhcm4kMTtcclxuXHJcbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcclxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cclxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XHJcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xyXG5cclxuZnVuY3Rpb24gbW9kZWwgKFxyXG4gIGVsLFxyXG4gIGRpcixcclxuICBfd2FyblxyXG4pIHtcclxuICB3YXJuJDEgPSBfd2FybjtcclxuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XHJcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XHJcbiAgdmFyIHRhZyA9IGVsLnRhZztcclxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcblxyXG4gIHtcclxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xyXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xyXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcclxuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xyXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gZWxzZSB7XHJcbiAgICB3YXJuJDEoXHJcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xyXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xyXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXHJcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcclxuICBlbCxcclxuICB2YWx1ZSxcclxuICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xyXG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xyXG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xyXG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xyXG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcclxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xyXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcclxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcclxuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXHJcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXHJcbiAgICAgIClcclxuICApO1xyXG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxyXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXHJcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcclxuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXHJcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcclxuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcclxuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXHJcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KFskJHZdKSl9XCIgK1xyXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXHJcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXHJcbiAgICBudWxsLCB0cnVlXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXHJcbiAgICBlbCxcclxuICAgIHZhbHVlLFxyXG4gICAgbW9kaWZpZXJzXHJcbikge1xyXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcclxuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcclxuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcclxuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XHJcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcclxuICAgIGVsLFxyXG4gICAgdmFsdWUsXHJcbiAgICBtb2RpZmllcnNcclxuKSB7XHJcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xyXG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcclxuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXHJcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xyXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xyXG5cclxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xyXG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcclxuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XHJcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxyXG4gIGVsLFxyXG4gIHZhbHVlLFxyXG4gIG1vZGlmaWVyc1xyXG4pIHtcclxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcblxyXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcclxuICB7XHJcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XHJcbiAgICBpZiAodmFsdWUkMSkge1xyXG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XHJcbiAgICAgIHdhcm4kMShcclxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xyXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcclxuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xyXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xyXG4gIHZhciB0cmltID0gcmVmLnRyaW07XHJcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcclxuICB2YXIgZXZlbnQgPSBsYXp5XHJcbiAgICA/ICdjaGFuZ2UnXHJcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcclxuICAgICAgPyBSQU5HRV9UT0tFTlxyXG4gICAgICA6ICdpbnB1dCc7XHJcblxyXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XHJcbiAgaWYgKHRyaW0pIHtcclxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcclxuICB9XHJcbiAgaWYgKG51bWJlcikge1xyXG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcclxuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcclxuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XHJcbiAgfVxyXG5cclxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XHJcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xyXG4gIGlmICh0cmltIHx8IG51bWJlcikge1xyXG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxyXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXHJcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcclxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cclxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XHJcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XHJcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xyXG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcclxuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XHJcbiAgfVxyXG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XHJcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XHJcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xyXG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcclxuICB9XHJcbn1cclxuXHJcbnZhciB0YXJnZXQkMTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xyXG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcclxuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGQkMSAoXHJcbiAgZXZlbnQsXHJcbiAgaGFuZGxlcixcclxuICBvbmNlJCQxLFxyXG4gIGNhcHR1cmUsXHJcbiAgcGFzc2l2ZVxyXG4pIHtcclxuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcclxuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XHJcbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgIGV2ZW50LFxyXG4gICAgaGFuZGxlcixcclxuICAgIHN1cHBvcnRzUGFzc2l2ZVxyXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XHJcbiAgICAgIDogY2FwdHVyZVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZSQyIChcclxuICBldmVudCxcclxuICBoYW5kbGVyLFxyXG4gIGNhcHR1cmUsXHJcbiAgX3RhcmdldFxyXG4pIHtcclxuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgIGV2ZW50LFxyXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcclxuICAgIGNhcHR1cmVcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XHJcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XHJcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcclxuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xyXG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxyXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcclxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgdmFyIGtleSwgY3VyO1xyXG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XHJcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcclxuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxyXG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XHJcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcclxuICB9XHJcblxyXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xyXG4gICAgICBlbG1ba2V5XSA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKGtleSBpbiBwcm9wcykge1xyXG4gICAgY3VyID0gcHJvcHNba2V5XTtcclxuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxyXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcclxuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXHJcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cclxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XHJcbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcclxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcclxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XHJcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcclxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcclxuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXHJcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xyXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XHJcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbG1ba2V5XSA9IGN1cjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxyXG5cclxuXHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XHJcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXHJcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcclxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcclxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXHJcbiAgKSlcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xyXG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcclxuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcclxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XHJcbiAgLy8gIzYxNTdcclxuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcclxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxyXG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XHJcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xyXG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxyXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcclxuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcclxuICB9XHJcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcclxuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcclxufVxyXG5cclxudmFyIGRvbVByb3BzID0ge1xyXG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXHJcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XHJcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XHJcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzXHJcbn0pO1xyXG5cclxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XHJcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xyXG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxyXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XHJcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcclxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxyXG4gICAgOiBzdHlsZVxyXG59XHJcblxyXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xyXG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxyXG4gIH1cclxuICByZXR1cm4gYmluZGluZ1N0eWxlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXHJcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcclxuICB2YXIgcmVzID0ge307XHJcbiAgdmFyIHN0eWxlRGF0YTtcclxuXHJcbiAgaWYgKGNoZWNrQ2hpbGQpIHtcclxuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xyXG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xyXG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICB9XHJcblxyXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XHJcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xyXG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cclxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxyXG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxuXHJcbnZhciBlbXB0eVN0eWxlO1xyXG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XHJcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xyXG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xyXG4gICAgcmV0dXJuIHByb3BcclxuICB9XHJcbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcclxuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgcmV0dXJuIG5hbWVcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XHJcblxyXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcclxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxyXG4gICkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgY3VyLCBuYW1lO1xyXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xyXG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xyXG5cclxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxyXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcclxuXHJcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xyXG5cclxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXHJcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xyXG4gIC8vIHRvIG11dGF0ZSBpdC5cclxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcclxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcclxuICAgIDogc3R5bGU7XHJcblxyXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcclxuXHJcbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XHJcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcclxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcclxuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xyXG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcclxuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcclxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgc3R5bGUgPSB7XHJcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcclxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cclxuICogU1ZHIGVsZW1lbnRzIGluIElFXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XHJcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xyXG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcclxuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xyXG4gICAgfVxyXG4gICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcclxuICBpZiAoIWRlZikge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICB9XHJcbiAgICBleHRlbmQocmVzLCBkZWYpO1xyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcclxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcclxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcclxudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuXHJcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcclxudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xyXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xyXG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xyXG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcclxuaWYgKGhhc1RyYW5zaXRpb24pIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xyXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xyXG4gIH1cclxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XHJcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXHJcbnZhciByYWYgPSBpbkJyb3dzZXJcclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcclxuICAgIDogc2V0VGltZW91dFxyXG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xyXG5cclxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xyXG4gIHJhZihmdW5jdGlvbiAoKSB7XHJcbiAgICByYWYoZm4pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcclxuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xyXG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xyXG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcclxuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xyXG4gIH1cclxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcclxuICBlbCxcclxuICBleHBlY3RlZFR5cGUsXHJcbiAgY2JcclxuKSB7XHJcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcclxuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcclxuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxyXG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICB2YXIgZW5kZWQgPSAwO1xyXG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbiAgICBjYigpO1xyXG4gIH07XHJcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcclxuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgZW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgIGVuZCgpO1xyXG4gICAgfVxyXG4gIH0sIHRpbWVvdXQgKyAxKTtcclxuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxuXHJcbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XHJcblxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcclxuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xyXG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XHJcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XHJcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuXHJcbiAgdmFyIHR5cGU7XHJcbiAgdmFyIHRpbWVvdXQgPSAwO1xyXG4gIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXHJcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XHJcbiAgICAgICAgPyBUUkFOU0lUSU9OXHJcbiAgICAgICAgOiBBTklNQVRJT05cclxuICAgICAgOiBudWxsO1xyXG4gICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMDtcclxuICB9XHJcbiAgdmFyIGhhc1RyYW5zZm9ybSA9XHJcbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXHJcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcclxuICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gdG9NcyAocykge1xyXG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xyXG4gIHZhciBlbCA9IHZub2RlLmVsbTtcclxuXHJcbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcclxuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgZWwuX2xlYXZlQ2IoKTtcclxuICB9XHJcblxyXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcclxuICBpZiAoaXNVbmRlZihkYXRhKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcclxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcclxuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XHJcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcclxuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcclxuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xyXG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XHJcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcclxuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcclxuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xyXG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcclxuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XHJcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcclxuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XHJcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xyXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxyXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXHJcbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcclxuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XHJcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xyXG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XHJcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcclxuICB9XHJcblxyXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcclxuXHJcbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXHJcbiAgICA/IGFwcGVhckNsYXNzXHJcbiAgICA6IGVudGVyQ2xhc3M7XHJcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcclxuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcclxuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcclxuICAgID8gYXBwZWFyVG9DbGFzc1xyXG4gICAgOiBlbnRlclRvQ2xhc3M7XHJcblxyXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxyXG4gICAgOiBiZWZvcmVFbnRlcjtcclxuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcclxuICAgIDogZW50ZXI7XHJcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXHJcbiAgICA6IGFmdGVyRW50ZXI7XHJcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXHJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXHJcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xyXG5cclxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXHJcbiAgICBpc09iamVjdChkdXJhdGlvbilcclxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxyXG4gICAgICA6IGR1cmF0aW9uXHJcbiAgKTtcclxuXHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XHJcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcclxuXHJcbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XHJcbiAgICB9XHJcbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XHJcbiAgfSk7XHJcblxyXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xyXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xyXG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcclxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxyXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxyXG4gICAgICApIHtcclxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcclxuICAgICAgfVxyXG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cclxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcclxuICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcclxuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcclxuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICB9XHJcblxyXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgY2IoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcclxuICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcblxyXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XHJcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xyXG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XHJcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcclxuICAgIHJldHVybiBybSgpXHJcbiAgfVxyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcclxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcclxuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XHJcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XHJcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcclxuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xyXG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xyXG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XHJcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XHJcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xyXG5cclxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXHJcbiAgICBpc09iamVjdChkdXJhdGlvbilcclxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxyXG4gICAgICA6IGR1cmF0aW9uXHJcbiAgKTtcclxuXHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xyXG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcclxuICAgIH1cclxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcclxuICB9KTtcclxuXHJcbiAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xyXG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxyXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcclxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XHJcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcclxuICAgIH1cclxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcclxuICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XHJcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgY2IoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXHJcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXHJcbiAgICAgIHZub2RlLmNvbnRleHRcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICB3YXJuKFxyXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXHJcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcclxuICAgICAgdm5vZGUuY29udGV4dFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcclxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXHJcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxyXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xyXG4gIGlmIChpc1VuZGVmKGZuKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xyXG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xyXG4gICAgLy8gaW52b2tlclxyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXHJcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcclxuICAgICAgICA/IGludm9rZXJGbnNbMF1cclxuICAgICAgICA6IGludm9rZXJGbnNcclxuICAgIClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XHJcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgZW50ZXIodm5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XHJcbiAgY3JlYXRlOiBfZW50ZXIsXHJcbiAgYWN0aXZhdGU6IF9lbnRlcixcclxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xyXG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcm0oKTtcclxuICAgIH1cclxuICB9XHJcbn0gOiB7fTtcclxuXHJcbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXHJcbiAgYXR0cnMsXHJcbiAga2xhc3MsXHJcbiAgZXZlbnRzLFxyXG4gIGRvbVByb3BzLFxyXG4gIHN0eWxlLFxyXG4gIHRyYW5zaXRpb25cclxuXTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXHJcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXHJcbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XHJcblxyXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcclxuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cclxuICovXHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKGlzSUU5KSB7XHJcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcclxuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBkaXJlY3RpdmUgPSB7XHJcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XHJcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAvLyAjNjkwM1xyXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcclxuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcclxuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XHJcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXHJcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcclxuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGlzSUU5KSB7XHJcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcclxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxyXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcclxuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXHJcbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcclxuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XHJcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcclxuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxyXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXHJcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXHJcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcclxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcclxuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcclxuICAgIH0sIDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcclxuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcclxuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXHJcbiAgICAgIHZtXHJcbiAgICApO1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcclxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcclxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xyXG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cclxuICAgID8gb3B0aW9uLl92YWx1ZVxyXG4gICAgOiBvcHRpb24udmFsdWVcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XHJcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xyXG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXHJcbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cclxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcclxuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XHJcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XHJcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxyXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcclxuICAgIDogdm5vZGVcclxufVxyXG5cclxudmFyIHNob3cgPSB7XHJcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcclxuXHJcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcclxuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxyXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xyXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxyXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xyXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcclxuICAgIGVsLFxyXG4gICAgYmluZGluZyxcclxuICAgIHZub2RlLFxyXG4gICAgb2xkVm5vZGUsXHJcbiAgICBpc0Rlc3Ryb3lcclxuICApIHtcclxuICAgIGlmICghaXNEZXN0cm95KSB7XHJcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcclxuICBtb2RlbDogZGlyZWN0aXZlLFxyXG4gIHNob3c6IHNob3dcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cclxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXHJcblxyXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xyXG4gIG5hbWU6IFN0cmluZyxcclxuICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgY3NzOiBCb29sZWFuLFxyXG4gIG1vZGU6IFN0cmluZyxcclxuICB0eXBlOiBTdHJpbmcsXHJcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxyXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcclxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcclxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXHJcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxyXG59O1xyXG5cclxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XHJcbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXHJcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcclxuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2bm9kZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XHJcbiAgdmFyIGRhdGEgPSB7fTtcclxuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XHJcbiAgLy8gcHJvcHNcclxuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcclxuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcclxuICB9XHJcbiAgLy8gZXZlbnRzLlxyXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xyXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVxyXG59XHJcblxyXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcclxuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XHJcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcclxuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcclxuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xyXG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xyXG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xyXG59XHJcblxyXG52YXIgVHJhbnNpdGlvbiA9IHtcclxuICBuYW1lOiAndHJhbnNpdGlvbicsXHJcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcclxuICBhYnN0cmFjdDogdHJ1ZSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xyXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXHJcbiAgICAgICAgdGhpcy4kcGFyZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XHJcblxyXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXHJcbiAgICApIHtcclxuICAgICAgd2FybihcclxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXHJcbiAgICAgICAgdGhpcy4kcGFyZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XHJcblxyXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xyXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXHJcbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXHJcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXHJcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgIHJldHVybiByYXdDaGlsZFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XHJcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxyXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xyXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxyXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xyXG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcclxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcclxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXHJcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xyXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcclxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxyXG4gICAgICAgIDogY2hpbGQua2V5O1xyXG5cclxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XHJcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcclxuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XHJcblxyXG4gICAgLy8gbWFyayB2LXNob3dcclxuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxyXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XHJcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBvbGRDaGlsZCAmJlxyXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXHJcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXHJcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXHJcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXHJcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcclxuICAgICkge1xyXG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcclxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxyXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XHJcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcclxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXHJcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXHJcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcclxuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJhd0NoaWxkXHJcbiAgfVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXHJcbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxyXG5cclxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxyXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcclxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3NlczpcclxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXHJcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXHJcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXHJcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxyXG5cclxudmFyIHByb3BzID0gZXh0ZW5kKHtcclxuICB0YWc6IFN0cmluZyxcclxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xyXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xyXG5cclxuZGVsZXRlIHByb3BzLm1vZGU7XHJcblxyXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xyXG4gIHByb3BzOiBwcm9wcyxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcclxuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XHJcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcclxuICAgICAgaWYgKGMudGFnKSB7XHJcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XHJcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xyXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xyXG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICB2YXIga2VwdCA9IFtdO1xyXG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcclxuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XHJcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XHJcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcclxuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxyXG4gIH0sXHJcblxyXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcclxuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcclxuICAgIHRoaXMuX19wYXRjaF9fKFxyXG4gICAgICB0aGlzLl92bm9kZSxcclxuICAgICAgdGhpcy5rZXB0LFxyXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXHJcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxyXG4gICAgKTtcclxuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XHJcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xyXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cclxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xyXG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xyXG5cclxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcclxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XHJcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XHJcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xyXG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xyXG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBtZXRob2RzOiB7XHJcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcclxuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgICAgLy8gaXMgYXBwbGllZC5cclxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcclxuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XHJcbiAgICBjLmVsbS5fbW92ZUNiKCk7XHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xyXG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XHJcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XHJcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XHJcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XHJcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICBpZiAoZHggfHwgZHkpIHtcclxuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XHJcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xyXG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xyXG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcclxuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxyXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcclxuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XHJcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcclxuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XHJcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XHJcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcclxuXHJcbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xyXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xyXG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xyXG5cclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxyXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xyXG5cclxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxyXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxyXG4gIGVsLFxyXG4gIGh5ZHJhdGluZ1xyXG4pIHtcclxuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcclxuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcclxufTtcclxuXHJcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblZ1ZSQzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcclxuICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcclxuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXHJcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xyXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxyXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xyXG4gICkge1xyXG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXHJcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcclxuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xyXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcclxuICAgICk7XHJcbiAgfVxyXG59LCAwKTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XHJcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcclxuXHJcbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XHJcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xyXG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcclxufSk7XHJcblxyXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxyXG4gIHRleHQsXHJcbiAgZGVsaW1pdGVyc1xyXG4pIHtcclxuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcclxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICB2YXIgdG9rZW5zID0gW107XHJcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XHJcbiAgdmFyIG1hdGNoLCBpbmRleDtcclxuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcclxuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XHJcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cclxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XHJcbiAgICB9XHJcbiAgICAvLyB0YWcgdG9rZW5cclxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcclxuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcclxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gIH1cclxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xyXG4gIH1cclxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XHJcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XHJcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XHJcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcclxuICAgIGlmIChleHByZXNzaW9uKSB7XHJcbiAgICAgIHdhcm4oXHJcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0aWNDbGFzcykge1xyXG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XHJcbiAgfVxyXG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcclxuICBpZiAoY2xhc3NCaW5kaW5nKSB7XHJcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xyXG4gIHZhciBkYXRhID0gJyc7XHJcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XHJcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcclxuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhXHJcbn1cclxuXHJcbnZhciBrbGFzcyQxID0ge1xyXG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcclxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxyXG4gIGdlbkRhdGE6IGdlbkRhdGFcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xyXG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xyXG4gIGlmIChzdGF0aWNTdHlsZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICB7XHJcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xyXG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHdhcm4oXHJcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXHJcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XHJcbiAgfVxyXG5cclxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XHJcbiAgaWYgKHN0eWxlQmluZGluZykge1xyXG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xyXG4gIHZhciBkYXRhID0gJyc7XHJcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XHJcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcclxuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxudmFyIHN0eWxlJDEgPSB7XHJcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxyXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcclxuICBnZW5EYXRhOiBnZW5EYXRhJDFcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGRlY29kZXI7XHJcblxyXG52YXIgaGUgPSB7XHJcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcclxuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcclxuICB9XHJcbn07XHJcblxyXG4vKiAgKi9cclxuXHJcbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcclxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXHJcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xyXG4pO1xyXG5cclxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXHJcbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcclxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxyXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xyXG4pO1xyXG5cclxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xyXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcclxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxyXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXHJcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcclxuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXHJcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcclxuICAndGl0bGUsdHIsdHJhY2snXHJcbik7XHJcblxyXG4vKipcclxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXHJcbiAqL1xyXG5cclxuLyohXHJcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcclxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XHJcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcclxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcclxuICovXHJcblxyXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcclxudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xyXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcclxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcclxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xyXG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xyXG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XHJcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XHJcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcclxudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcclxudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xyXG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XHJcblxyXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xyXG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcclxuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XHJcbn0pO1xyXG5cclxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXHJcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcclxudmFyIHJlQ2FjaGUgPSB7fTtcclxuXHJcbnZhciBkZWNvZGluZ01hcCA9IHtcclxuICAnJmx0Oyc6ICc8JyxcclxuICAnJmd0Oyc6ICc+JyxcclxuICAnJnF1b3Q7JzogJ1wiJyxcclxuICAnJmFtcDsnOiAnJicsXHJcbiAgJyYjMTA7JzogJ1xcbicsXHJcbiAgJyYjOTsnOiAnXFx0J1xyXG59O1xyXG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcclxudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTB8IzkpOy9nO1xyXG5cclxuLy8gIzU5OTJcclxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xyXG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xyXG5cclxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XHJcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xyXG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XHJcbiAgdmFyIHN0YWNrID0gW107XHJcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XHJcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XHJcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICB2YXIgbGFzdCwgbGFzdFRhZztcclxuICB3aGlsZSAoaHRtbCkge1xyXG4gICAgbGFzdCA9IGh0bWw7XHJcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxyXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcclxuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcclxuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcclxuICAgICAgICAvLyBDb21tZW50OlxyXG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxyXG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xyXG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xyXG5cclxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvY3R5cGU6XHJcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XHJcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xyXG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbmQgdGFnOlxyXG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcclxuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcclxuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhcnQgdGFnOlxyXG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xyXG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XHJcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcclxuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcclxuICAgICAgICAgICAgYWR2YW5jZSgxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcclxuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xyXG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xyXG4gICAgICAgIHdoaWxlIChcclxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXHJcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XHJcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XHJcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxyXG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xyXG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcclxuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcclxuICAgICAgICB0ZXh0ID0gaHRtbDtcclxuICAgICAgICBodG1sID0gJyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcclxuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcclxuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcclxuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xyXG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xyXG4gICAgICAgICAgdGV4dCA9IHRleHRcclxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcclxuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xyXG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgIH0pO1xyXG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XHJcbiAgICAgIGh0bWwgPSByZXN0JDE7XHJcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcclxuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xyXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcclxuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXHJcbiAgcGFyc2VFbmRUYWcoKTtcclxuXHJcbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xyXG4gICAgaW5kZXggKz0gbjtcclxuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xyXG4gICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IHtcclxuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcclxuICAgICAgICBhdHRyczogW10sXHJcbiAgICAgICAgc3RhcnQ6IGluZGV4XHJcbiAgICAgIH07XHJcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIGVuZCwgYXR0cjtcclxuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XHJcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcclxuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xyXG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xyXG4gICAgICAgIHJldHVybiBtYXRjaFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcclxuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcclxuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcclxuXHJcbiAgICBpZiAoZXhwZWN0SFRNTCkge1xyXG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcclxuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XHJcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcclxuXHJcbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcclxuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XHJcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxyXG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcclxuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cclxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cclxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcclxuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xyXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcclxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XHJcbiAgICAgIGF0dHJzW2ldID0ge1xyXG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXHJcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XHJcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XHJcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcclxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cclxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxyXG5cclxuICAgIGlmICh0YWdOYW1lKSB7XHJcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICBpZiAodGFnTmFtZSkge1xyXG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcclxuICAgICAgcG9zID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zID49IDApIHtcclxuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcclxuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcclxuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxyXG4gICAgICAgICAgb3B0aW9ucy53YXJuXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBvcHRpb25zLndhcm4oXHJcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xyXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XHJcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xyXG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xyXG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcclxuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcclxudmFyIGRpclJFID0gL152LXxeQHxeOi87XHJcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcclxudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XHJcblxyXG52YXIgYXJnUkUgPSAvOiguKikkLztcclxudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XHJcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XHJcblxyXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xyXG5cclxuLy8gY29uZmlndXJhYmxlIHN0YXRlXHJcbnZhciB3YXJuJDI7XHJcbnZhciBkZWxpbWl0ZXJzO1xyXG52YXIgdHJhbnNmb3JtcztcclxudmFyIHByZVRyYW5zZm9ybXM7XHJcbnZhciBwb3N0VHJhbnNmb3JtcztcclxudmFyIHBsYXRmb3JtSXNQcmVUYWc7XHJcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xyXG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxyXG4gIHRhZyxcclxuICBhdHRycyxcclxuICBwYXJlbnRcclxuKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IDEsXHJcbiAgICB0YWc6IHRhZyxcclxuICAgIGF0dHJzTGlzdDogYXR0cnMsXHJcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcclxuICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgY2hpbGRyZW46IFtdXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSAoXHJcbiAgdGVtcGxhdGUsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcblxyXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xyXG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xyXG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XHJcblxyXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcclxuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XHJcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XHJcblxyXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XHJcblxyXG4gIHZhciBzdGFjayA9IFtdO1xyXG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XHJcbiAgdmFyIHJvb3Q7XHJcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XHJcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xyXG4gIHZhciBpblByZSA9IGZhbHNlO1xyXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xyXG4gICAgaWYgKCF3YXJuZWQpIHtcclxuICAgICAgd2FybmVkID0gdHJ1ZTtcclxuICAgICAgd2FybiQyKG1zZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcclxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxyXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgIGluVlByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgIGluUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcclxuICAgIHdhcm46IHdhcm4kMixcclxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcclxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcclxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcclxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcclxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xyXG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXHJcbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG5cclxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xyXG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcclxuICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxyXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xyXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXHJcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaW5WUHJlKSB7XHJcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcclxuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcclxuICAgICAgICAgIGluVlByZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIGluUHJlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5WUHJlKSB7XHJcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xyXG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XHJcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xyXG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xyXG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcclxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXHJcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKFxyXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcclxuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcclxuICAgICAgaWYgKCFyb290KSB7XHJcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxyXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XHJcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcclxuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcclxuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcclxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3YXJuT25jZShcclxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXHJcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXHJcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcclxuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxyXG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcclxuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcclxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xyXG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XHJcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcclxuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHBvcCBzdGFja1xyXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcclxuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICBlbmRQcmUoZWxlbWVudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xyXG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgd2Fybk9uY2UoXHJcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcclxuICAgICAgICAgICAgd2Fybk9uY2UoXHJcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoaXNJRSAmJlxyXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXHJcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcclxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXHJcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcclxuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcclxuICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcclxuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XHJcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogMixcclxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgdGV4dDogdGV4dFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XHJcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XHJcbiAgICAgICAgdHlwZTogMyxcclxuICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcm9vdFxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xyXG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XHJcbiAgICBlbC5wcmUgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xyXG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcclxuICBpZiAobCkge1xyXG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBhdHRyc1tpXSA9IHtcclxuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcclxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xyXG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xyXG4gICAgZWwucGxhaW4gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xyXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcclxuXHJcbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcclxuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcclxuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcclxuICB9XHJcbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xyXG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gIGlmIChleHApIHtcclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxuICAgIGVsLmtleSA9IGV4cDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XHJcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XHJcbiAgaWYgKHJlZikge1xyXG4gICAgZWwucmVmID0gcmVmO1xyXG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XHJcbiAgdmFyIGV4cDtcclxuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xyXG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpIHtcclxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxyXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XHJcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcclxuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XHJcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcclxuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcclxuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcclxuICBpZiAoZXhwKSB7XHJcbiAgICBlbC5pZiA9IGV4cDtcclxuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XHJcbiAgICAgIGV4cDogZXhwLFxyXG4gICAgICBibG9jazogZWxcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcclxuICAgICAgZWwuZWxzZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xyXG4gICAgaWYgKGVsc2VpZikge1xyXG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XHJcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcclxuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XHJcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XHJcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxyXG4gICAgICBibG9jazogZWxcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3YXJuJDIoXHJcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xyXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcclxuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcclxuICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcclxuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBjaGlsZHJlbi5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XHJcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcclxuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xyXG4gIH1cclxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcclxuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcclxuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XHJcbiAgICBlbC5vbmNlID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xyXG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xyXG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcclxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcclxuICAgICAgd2FybiQyKFxyXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXHJcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXHJcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgc2xvdFNjb3BlO1xyXG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcclxuICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXHJcbiAgICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXHJcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXHJcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcclxuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcclxuICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXHJcbiAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXHJcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcclxuICAgIH1cclxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XHJcbiAgICBpZiAoc2xvdFRhcmdldCkge1xyXG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XHJcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcclxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cclxuICAgICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XHJcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcclxuICB2YXIgYmluZGluZztcclxuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XHJcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xyXG4gIH1cclxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcclxuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcclxuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcclxuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xyXG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XHJcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XHJcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xyXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XHJcbiAgICAgIC8vIG1vZGlmaWVyc1xyXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcclxuICAgICAgaWYgKG1vZGlmaWVycykge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcclxuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcclxuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xyXG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxyXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcclxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XHJcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XHJcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xyXG4gICAgICAgIC8vIHBhcnNlIGFyZ1xyXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xyXG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcclxuICAgICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcclxuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xyXG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xyXG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICB3YXJuJDIoXHJcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xyXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcclxuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXHJcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxyXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxyXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XHJcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcclxuICB2YXIgcGFyZW50ID0gZWw7XHJcbiAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XHJcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcclxuICBpZiAobWF0Y2gpIHtcclxuICAgIHZhciByZXQgPSB7fTtcclxuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XHJcbiAgICByZXR1cm4gcmV0XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XHJcbiAgdmFyIG1hcCA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXHJcbiAgICApIHtcclxuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XHJcbiAgICB9XHJcbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIG1hcFxyXG59XHJcblxyXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcclxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xyXG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcclxuICByZXR1cm4gKFxyXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XHJcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXHJcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XHJcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXHJcbiAgICApKVxyXG4gIClcclxufVxyXG5cclxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XHJcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XHJcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcclxuICAgICAgcmVzLnB1c2goYXR0cik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcclxuICB2YXIgX2VsID0gZWw7XHJcbiAgd2hpbGUgKF9lbCkge1xyXG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xyXG4gICAgICB3YXJuJDIoXHJcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXHJcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xyXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xyXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xyXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbi8qKlxyXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeWFubWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXHJcbiAqIFR1cm4gdGhpczpcclxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cclxuICogaW50byB0aGlzOlxyXG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XHJcbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxyXG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cclxuICovXHJcblxyXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xyXG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcclxuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcclxuICAgIGlmIChtYXBbJ3YtbW9kZWwnXSAmJiAobWFwWyd2LWJpbmQ6dHlwZSddIHx8IG1hcFsnOnR5cGUnXSkpIHtcclxuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XHJcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcclxuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcclxuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcclxuICAgICAgLy8gMS4gY2hlY2tib3hcclxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXHJcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XHJcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XHJcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcclxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cclxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XHJcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xyXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcclxuICAgICAgICBibG9jazogYnJhbmNoMVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gMy4gb3RoZXJcclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xyXG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xyXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcclxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XHJcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcclxuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxyXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGhhc0Vsc2UpIHtcclxuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xyXG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYnJhbmNoMFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xyXG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcclxuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxufVxyXG5cclxudmFyIG1vZGVsJDIgPSB7XHJcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxyXG59O1xyXG5cclxudmFyIG1vZHVsZXMkMSA9IFtcclxuICBrbGFzcyQxLFxyXG4gIHN0eWxlJDEsXHJcbiAgbW9kZWwkMlxyXG5dO1xyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XHJcbiAgaWYgKGRpci52YWx1ZSkge1xyXG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiAgKi9cclxuXHJcbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcclxuICBpZiAoZGlyLnZhbHVlKSB7XHJcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZGlyZWN0aXZlcyQxID0ge1xyXG4gIG1vZGVsOiBtb2RlbCxcclxuICB0ZXh0OiB0ZXh0LFxyXG4gIGh0bWw6IGh0bWxcclxufTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGJhc2VPcHRpb25zID0ge1xyXG4gIGV4cGVjdEhUTUw6IHRydWUsXHJcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxyXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcclxuICBpc1ByZVRhZzogaXNQcmVUYWcsXHJcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcclxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXHJcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcclxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxyXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxyXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgaXNTdGF0aWNLZXk7XHJcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XHJcblxyXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xyXG5cclxuLyoqXHJcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXHJcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcclxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cclxuICpcclxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XHJcbiAqXHJcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cclxuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xyXG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cclxuICovXHJcbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XHJcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XHJcbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XHJcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXHJcbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xyXG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cclxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcclxuICByZXR1cm4gbWFrZU1hcChcclxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXHJcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xyXG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXHJcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXHJcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXHJcbiAgICBpZiAoXHJcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXHJcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcclxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xyXG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xyXG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xyXG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XHJcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcclxuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcclxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXHJcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXHJcbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcclxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXHJcbiAgICApKSB7XHJcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcclxuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxyXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xyXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxyXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cclxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XHJcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcclxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxyXG4gICkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XHJcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5mb3IpIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcclxudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xyXG5cclxuLy8ga2V5Q29kZSBhbGlhc2VzXHJcbnZhciBrZXlDb2RlcyA9IHtcclxuICBlc2M6IDI3LFxyXG4gIHRhYjogOSxcclxuICBlbnRlcjogMTMsXHJcbiAgc3BhY2U6IDMyLFxyXG4gIHVwOiAzOCxcclxuICBsZWZ0OiAzNyxcclxuICByaWdodDogMzksXHJcbiAgZG93bjogNDAsXHJcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cclxufTtcclxuXHJcbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXHJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcclxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxyXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcclxuXHJcbnZhciBtb2RpZmllckNvZGUgPSB7XHJcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxyXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxyXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXHJcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXHJcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcclxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXHJcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXHJcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcclxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXHJcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcclxuICBldmVudHMsXHJcbiAgaXNOYXRpdmUsXHJcbiAgd2FyblxyXG4pIHtcclxuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XHJcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcclxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xyXG4gIH1cclxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcclxuICBuYW1lLFxyXG4gIGhhbmRsZXJcclxuKSB7XHJcbiAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XHJcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXHJcbiAgfVxyXG5cclxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XHJcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xyXG5cclxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XHJcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXHJcbiAgICAgID8gaGFuZGxlci52YWx1ZVxyXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29kZSA9ICcnO1xyXG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xyXG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcclxuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XHJcbiAgICAgICAgLy8gbGVmdC9yaWdodFxyXG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XHJcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XHJcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxyXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcclxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XHJcbiAgICB9XHJcbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xyXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xyXG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcclxuICAgIH1cclxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxyXG4gICAgICA/IGhhbmRsZXIudmFsdWUgKyAnKCRldmVudCknXHJcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cclxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXHJcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xyXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xyXG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xyXG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcclxuICBpZiAoa2V5VmFsKSB7XHJcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcclxuICB9XHJcbiAgdmFyIGNvZGUgPSBrZXlDb2Rlc1trZXldO1xyXG4gIHJldHVybiAoXHJcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcclxuICAgIChKU09OLnN0cmluZ2lmeShjb2RlKSkgKyBcIixcIiArXHJcbiAgICBcIiRldmVudC5rZXkpXCJcclxuICApXHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xyXG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XHJcbiAgfVxyXG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcclxuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXHJcbiAgfTtcclxufVxyXG5cclxuLyogICovXHJcblxyXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XHJcbiAgb246IG9uLFxyXG4gIGJpbmQ6IGJpbmQkMSxcclxuICBjbG9hazogbm9vcFxyXG59O1xyXG5cclxuLyogICovXHJcblxyXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XHJcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XHJcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XHJcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XHJcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xyXG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xyXG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XHJcbiAgdGhpcy5vbmNlSWQgPSAwO1xyXG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlIChcclxuICBhc3QsXHJcbiAgb3B0aW9uc1xyXG4pIHtcclxuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xyXG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxyXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xyXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xyXG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XHJcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxyXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xyXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcclxuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcclxuICAgIHZhciBjb2RlO1xyXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcclxuXHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XHJcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2RlXHJcbiAgfVxyXG59XHJcblxyXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxyXG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSwgb25jZSQkMSkge1xyXG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XHJcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XHJcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIFwiLFwiICsgKGVsLnN0YXRpY0luRm9yID8gJ3RydWUnIDogJ2ZhbHNlJykgKyBcIixcIiArIChvbmNlJCQxID8gJ3RydWUnIDogJ2ZhbHNlJykgKyBcIilcIilcclxufVxyXG5cclxuLy8gdi1vbmNlXHJcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xyXG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xyXG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXHJcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xyXG4gICAgdmFyIGtleSA9ICcnO1xyXG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcclxuICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcclxuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxuICAgIGlmICgha2V5KSB7XHJcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXHJcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSwgdHJ1ZSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbklmIChcclxuICBlbCxcclxuICBzdGF0ZSxcclxuICBhbHRHZW4sXHJcbiAgYWx0RW1wdHlcclxuKSB7XHJcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcclxuICBjb25kaXRpb25zLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRFbXB0eVxyXG4pIHtcclxuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXHJcbiAgfVxyXG5cclxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xyXG4gIGlmIChjb25kaXRpb24uZXhwKSB7XHJcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXHJcbiAgfVxyXG5cclxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXHJcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcclxuICAgIHJldHVybiBhbHRHZW5cclxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxyXG4gICAgICA6IGVsLm9uY2VcclxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxyXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Gb3IgKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGFsdEdlbixcclxuICBhbHRIZWxwZXJcclxuKSB7XHJcbiAgdmFyIGV4cCA9IGVsLmZvcjtcclxuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XHJcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xyXG5cclxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxyXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcclxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxyXG4gICAgIWVsLmtleVxyXG4gICkge1xyXG4gICAgc3RhdGUud2FybihcclxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXHJcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xyXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXHJcbiAgICAgIHRydWUgLyogdGlwICovXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXHJcbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xyXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcclxuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXHJcbiAgICAnfSknXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XHJcbiAgdmFyIGRhdGEgPSAneyc7XHJcblxyXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXHJcbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cclxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcclxuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cclxuXHJcbiAgLy8ga2V5XHJcbiAgaWYgKGVsLmtleSkge1xyXG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XHJcbiAgfVxyXG4gIC8vIHJlZlxyXG4gIGlmIChlbC5yZWYpIHtcclxuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xyXG4gIH1cclxuICBpZiAoZWwucmVmSW5Gb3IpIHtcclxuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xyXG4gIH1cclxuICAvLyBwcmVcclxuICBpZiAoZWwucHJlKSB7XHJcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XHJcbiAgfVxyXG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXHJcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcclxuICB9XHJcbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XHJcbiAgfVxyXG4gIC8vIGF0dHJpYnV0ZXNcclxuICBpZiAoZWwuYXR0cnMpIHtcclxuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcclxuICB9XHJcbiAgLy8gRE9NIHByb3BzXHJcbiAgaWYgKGVsLnByb3BzKSB7XHJcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XHJcbiAgfVxyXG4gIC8vIGV2ZW50IGhhbmRsZXJzXHJcbiAgaWYgKGVsLmV2ZW50cykge1xyXG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XHJcbiAgfVxyXG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcclxuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XHJcbiAgfVxyXG4gIC8vIHNsb3QgdGFyZ2V0XHJcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xyXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcclxuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XHJcbiAgfVxyXG4gIC8vIHNjb3BlZCBzbG90c1xyXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xyXG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcclxuICB9XHJcbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcclxuICBpZiAoZWwubW9kZWwpIHtcclxuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcclxuICB9XHJcbiAgLy8gaW5saW5lLXRlbXBsYXRlXHJcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XHJcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xyXG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XHJcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcclxuICAgIH1cclxuICB9XHJcbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XHJcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxyXG4gIGlmIChlbC53cmFwRGF0YSkge1xyXG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xyXG4gIH1cclxuICAvLyB2LW9uIGRhdGEgd3JhcFxyXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XHJcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XHJcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xyXG4gIGlmICghZGlycykgeyByZXR1cm4gfVxyXG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcclxuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xyXG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xyXG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgZGlyID0gZGlyc1tpXTtcclxuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcclxuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcclxuICAgIGlmIChnZW4pIHtcclxuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cclxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XHJcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xyXG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGhhc1J1bnRpbWUpIHtcclxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XHJcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xyXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAoXHJcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcclxuICApKSB7XHJcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcclxuICB9XHJcbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XHJcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcclxuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXHJcbiAgc2xvdHMsXHJcbiAgc3RhdGVcclxuKSB7XHJcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcclxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxyXG4gIGtleSxcclxuICBlbCxcclxuICBzdGF0ZVxyXG4pIHtcclxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcclxuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxyXG4gIH1cclxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXHJcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcclxuICAgICAgPyBlbC5pZlxyXG4gICAgICAgID8gKChlbC5pZikgKyBcIj9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxyXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xyXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcclxuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXHJcbiAga2V5LFxyXG4gIGVsLFxyXG4gIHN0YXRlXHJcbikge1xyXG4gIHZhciBleHAgPSBlbC5mb3I7XHJcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XHJcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xyXG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcclxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xyXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcclxuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcclxuICAgICd9KSdcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxyXG4gIGVsLFxyXG4gIHN0YXRlLFxyXG4gIGNoZWNrU2tpcCxcclxuICBhbHRHZW5FbGVtZW50LFxyXG4gIGFsdEdlbk5vZGVcclxuKSB7XHJcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcclxuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICBlbCQxLmZvciAmJlxyXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxyXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKVxyXG4gICAgfVxyXG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXHJcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxyXG4gICAgICA6IDA7XHJcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xyXG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcclxuICB9XHJcbn1cclxuXHJcbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cclxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcclxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxyXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXHJcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcclxuICBjaGlsZHJlbixcclxuICBtYXliZUNvbXBvbmVudFxyXG4pIHtcclxuICB2YXIgcmVzID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcclxuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxyXG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XHJcbiAgICAgIHJlcyA9IDI7XHJcbiAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XHJcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xyXG4gICAgICByZXMgPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcclxuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXHJcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XHJcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xyXG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcclxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcclxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XHJcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xyXG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XHJcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcclxuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xyXG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XHJcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XHJcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcclxuICAgIHJlcyArPSBcIixudWxsXCI7XHJcbiAgfVxyXG4gIGlmIChhdHRycykge1xyXG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XHJcbiAgfVxyXG4gIGlmIChiaW5kJCQxKSB7XHJcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcyArICcpJ1xyXG59XHJcblxyXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XHJcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXHJcbiAgY29tcG9uZW50TmFtZSxcclxuICBlbCxcclxuICBzdGF0ZVxyXG4pIHtcclxuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xyXG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XHJcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XHJcbiAgfVxyXG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXHJcbn1cclxuXHJcbi8vICMzODk1LCAjNDI2OFxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcclxuICByZXR1cm4gdGV4dFxyXG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXHJcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5JylcclxufVxyXG5cclxuLyogICovXHJcblxyXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxyXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXHJcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxyXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xyXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXHJcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXHJcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XHJcblxyXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xyXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xyXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcclxuXHJcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcclxudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuXHJcbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXHJcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XHJcbiAgdmFyIGVycm9ycyA9IFtdO1xyXG4gIGlmIChhc3QpIHtcclxuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XHJcbiAgfVxyXG4gIHJldHVybiBlcnJvcnNcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcclxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcclxuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcclxuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xyXG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcclxuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcclxuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcclxuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcclxuICAgIGVycm9ycy5wdXNoKFxyXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xyXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXHJcbiAgICApO1xyXG4gIH1cclxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xyXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xyXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcclxuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXHJcbiAgaWRlbnQsXHJcbiAgdHlwZSxcclxuICB0ZXh0LFxyXG4gIGVycm9yc1xyXG4pIHtcclxuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xyXG4gICAgICBlcnJvcnMucHVzaChcclxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXJyb3JzLnB1c2goXHJcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcclxuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xyXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XHJcbiAgICByZXR1cm4gbm9vcFxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xyXG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxyXG4gICAgdGVtcGxhdGUsXHJcbiAgICBvcHRpb25zLFxyXG4gICAgdm1cclxuICApIHtcclxuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcclxuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICB7XHJcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xyXG4gICAgICAgICAgd2FybiQkMShcclxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xyXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXHJcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXHJcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcclxuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBjYWNoZVxyXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xyXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcclxuICAgICAgOiB0ZW1wbGF0ZTtcclxuICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcGlsZVxyXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcclxuICAgIHtcclxuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgd2FybiQkMShcclxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcclxuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcclxuICAgICAgICAgIHZtXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcclxuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcclxuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxyXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cclxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHdhcm4kJDEoXHJcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xyXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xyXG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgdm1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxyXG4gIH1cclxufVxyXG5cclxuLyogICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xyXG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXHJcbiAgICAgIHRlbXBsYXRlLFxyXG4gICAgICBvcHRpb25zXHJcbiAgICApIHtcclxuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xyXG4gICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgIHZhciB0aXBzID0gW107XHJcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XHJcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XHJcbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcclxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcclxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XHJcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XHJcbiAgICAgIHtcclxuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcclxuICAgICAgfVxyXG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xyXG4gICAgICByZXR1cm4gY29tcGlsZWRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb21waWxlOiBjb21waWxlLFxyXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qICAqL1xyXG5cclxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxyXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXHJcbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxyXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxyXG4gIHRlbXBsYXRlLFxyXG4gIG9wdGlvbnNcclxuKSB7XHJcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XHJcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcclxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFzdDogYXN0LFxyXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcclxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcclxuICB9XHJcbn0pO1xyXG5cclxuLyogICovXHJcblxyXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XHJcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XHJcblxyXG4vKiAgKi9cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXHJcbnZhciBkaXY7XHJcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xyXG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XHJcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcclxufVxyXG5cclxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcclxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xyXG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXHJcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcclxuXHJcbi8qICAqL1xyXG5cclxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcclxuICB2YXIgZWwgPSBxdWVyeShpZCk7XHJcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxyXG59KTtcclxuXHJcbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XHJcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXHJcbiAgZWwsXHJcbiAgaHlkcmF0aW5nXHJcbikge1xyXG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xyXG5cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcclxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XHJcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cclxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xyXG4gICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgd2FybihcclxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxyXG4gICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGVsKSB7XHJcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcclxuICAgIH1cclxuICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XHJcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxyXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcclxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XHJcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcclxuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XHJcblxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcclxuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxyXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cclxuICovXHJcbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcclxuICBpZiAoZWwub3V0ZXJIVE1MKSB7XHJcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcclxuICB9XHJcbn1cclxuXHJcblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XHJcblxyXG5yZXR1cm4gVnVlJDM7XHJcblxyXG59KSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RlbW8vdnVlLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMmYxN2M0MWJcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2Nhcm91c2VsLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9jYXJvdXNlbC52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9jYXJvdXNlbC52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTJmMTdjNDFiXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vY2Fyb3VzZWwudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IFwiZGF0YS12LTJmMTdjNDFiXCJcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImRlbW9cXFxcY2Fyb3VzZWwudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTJmMTdjNDFiXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMmYxN2M0MWJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZW1vL2Nhcm91c2VsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJmMTdjNDFiXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9jYXJvdXNlbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcImI4ZDU2NDllXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJmMTdjNDFiXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9jYXJvdXNlbC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMmYxN2M0MWJcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2Nhcm91c2VsLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yZjE3YzQxYlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2RlbW8vY2Fyb3VzZWwudnVlXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmNhcm91c2VsLTNkLWNvbnRhaW5lcltkYXRhLXYtMmYxN2M0MWJdIHtcXG4gICAgbWluLWhlaWdodDogMXB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB6LWluZGV4OiAwO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBtYXJnaW46IDIwcHggYXV0bztcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLmNhcm91c2VsLTNkLXNsaWRlcltkYXRhLXYtMmYxN2M0MWJdIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXG4gICAgLXdlYmtpdC1wZXJzcGVjdGl2ZTogMTAwMHB4O1xcbiAgICAtbW96LXBlcnNwZWN0aXZlOiAxMDAwcHg7XFxuICAgIHBlcnNwZWN0aXZlOiAxMDAwcHg7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9BZG1pbmlzdHJhdG9yL0RvY3VtZW50cy9HaXRIdWIvdnVlLXNsaWRlLXNob3cvZGVtby9kZW1vL2Nhcm91c2VsLnZ1ZT82YjJmNDY5YVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBc1pBO0lBQ0EsZ0JBQUE7SUFDQSxZQUFBO0lBQ0EsbUJBQUE7SUFDQSxXQUFBO0lBQ0EsaUJBQUE7SUFDQSxrQkFBQTtJQUNBLHVCQUFBO0NBQ0E7QUFDQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtJQUNBLDZCQUFBO0lBQ0EsNEJBQUE7SUFDQSx5QkFBQTtJQUNBLG9CQUFBO0NBQ0FcIixcImZpbGVcIjpcImNhcm91c2VsLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImNhcm91c2VsLTNkLWNvbnRhaW5lclxcXCIgOnN0eWxlPVxcXCJ7aGVpZ2h0OiB0aGlzLnNsaWRlSGVpZ2h0ICsgJ3B4J31cXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2Fyb3VzZWwtM2Qtc2xpZGVyXFxcIiA6c3R5bGU9XFxcInt3aWR0aDogdGhpcy5zbGlkZVdpZHRoICsgJ3B4JywgaGVpZ2h0OiB0aGlzLnNsaWRlSGVpZ2h0ICsgJ3B4J31cXFwiPlxcclxcbiAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcblxcclxcbjxzY3JpcHQ+XFxyXFxuICAgIGltcG9ydCBhdXRvcGxheSBmcm9tICcuL21peGlucy9hdXRvcGxheSdcXHJcXG4gICAgaW1wb3J0IFNsaWRlIGZyb20gJy4vc2xpZGUudnVlJ1xcclxcbiAgICBjb25zdCBub29wID0gKCkgPT4ge1xcclxcbiAgICB9XFxyXFxuICAgIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgICAgIG5hbWU6ICdjYXJvdXNlbDNkJyxcXHJcXG4gICAgICAgIGNvbXBvbmVudHM6IHtcXHJcXG4gICAgICAgICAgICBTbGlkZVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHByb3BzOiB7XFxyXFxuICAgICAgICAgICAgY291bnQ6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMzVcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogNVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbG9vcDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBhbmltYXRpb25TcGVlZDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MDBcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGRpcjoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdydGwnXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICB3aWR0aDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAzNjBcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGhlaWdodDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAyNzBcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJvcmRlcjoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBzcGFjZToge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnYXV0bydcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgY2xpY2thYmxlOiB7XFxyXFxuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGRpc2FibGUzZDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbWluU3dpcGVEaXN0YW5jZToge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEwXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBpbnZlcnNlU2NhbGluZzoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MDBcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGNvbnRyb2xzVmlzaWJsZToge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgY29udHJvbHNQcmV2SHRtbDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICcmbHNhcXVvOydcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGNvbnRyb2xzTmV4dEh0bWw6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnJnJzYXF1bzsnXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBjb250cm9sc1dpZHRoOiB7XFxyXFxuICAgICAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDUwXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBjb250cm9sc0hlaWdodDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgb25MYXN0U2xpZGU6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG5vb3BcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIG9uU2xpZGVDaGFuZ2U6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG5vb3BcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJpYXM6IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnbGVmdCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZGF0YSAoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IDAsXFxyXFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcXHJcXG4gICAgICAgICAgICAgICAgdG90YWw6IDAsXFxyXFxuICAgICAgICAgICAgICAgIGxvY2s6IGZhbHNlLFxcclxcbiAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0OiAwLFxcclxcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRYOiAwLFxcclxcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IGZhbHNlLFxcclxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtaXhpbnM6IFtcXHJcXG4gICAgICAgICAgICBhdXRvcGxheVxcclxcbiAgICAgICAgXSxcXHJcXG4gICAgICAgIHdhdGNoOiB7XFxyXFxuICAgICAgICAgICAgY291bnQgKCkge1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRhKClcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgICAgICBpc0xhc3RTbGlkZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA9PT0gdGhpcy50b3RhbCAtIDFcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGlzRmlyc3RTbGlkZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleCA9PT0gMFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgaXNOZXh0UG9zc2libGUgKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gISghdGhpcy5sb29wICYmIHRoaXMuaXNMYXN0U2xpZGUpXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBpc1ByZXZQb3NzaWJsZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAhKCF0aGlzLmxvb3AgJiYgdGhpcy5pc0ZpcnN0U2xpZGUpXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBzbGlkZVdpZHRoICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgdncgPSB0aGlzLnZpZXdwb3J0XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHN3ID0gcGFyc2VJbnQodGhpcy53aWR0aCkgKyAocGFyc2VJbnQodGhpcy5ib3JkZXIsIDEwKSAqIDIpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB2dyA8IHN3ID8gdncgOiBzd1xcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgc2xpZGVIZWlnaHQgKCkge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBzdyA9IHBhcnNlSW50KHRoaXMud2lkdGgsIDEwKSArIChwYXJzZUludCh0aGlzLmJvcmRlciwgMTApICogMilcXHJcXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ggPSBwYXJzZUludChwYXJzZUludCh0aGlzLmhlaWdodCkgKyAodGhpcy5ib3JkZXIgKiAyKSwgMTApXFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGFyID0gdGhpcy5jYWxjdWxhdGVBc3BlY3RSYXRpbyhzdywgc2gpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlV2lkdGggLyBhclxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgdmlzaWJsZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAodGhpcy5kaXNwbGF5ID4gdGhpcy50b3RhbCkgPyB0aGlzLnRvdGFsIDogdGhpcy5kaXNwbGF5XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBoYXNIaWRkZW5TbGlkZXMgKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbCA+IHRoaXMudmlzaWJsZVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbGVmdEluZGljZXMgKCkge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICh0aGlzLnZpc2libGUgLSAxKSAvIDJcXHJcXG4gICAgICAgICAgICAgICAgbiA9ICh0aGlzLmJpYXMudG9Mb3dlckNhc2UoKSA9PT0gJ2xlZnQnID8gTWF0aC5jZWlsKG4pIDogTWF0aC5mbG9vcihuKSlcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFtdXFxyXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IG47IG0rKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKCh0aGlzLmRpciA9PT0gJ2x0cicpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5jdXJyZW50SW5kZXggKyBtKSAlICh0aGlzLnRvdGFsKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY3VycmVudEluZGV4IC0gbSkgJSAodGhpcy50b3RhbCkpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIHJpZ2h0SW5kaWNlcyAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBuID0gKHRoaXMudmlzaWJsZSAtIDEpIC8gMlxcclxcbiAgICAgICAgICAgICAgICBuID0gKHRoaXMuYmlhcy50b0xvd2VyQ2FzZSgpID09PSAncmlnaHQnID8gTWF0aC5jZWlsKG4pIDogTWF0aC5mbG9vcihuKSlcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFtdXFxyXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IG47IG0rKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKCh0aGlzLmRpciA9PT0gJ2x0cicpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5jdXJyZW50SW5kZXggLSBtKSAlICh0aGlzLnRvdGFsKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY3VycmVudEluZGV4ICsgbSkgJSAodGhpcy50b3RhbCkpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGxlZnRPdXRJbmRleCAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBuID0gKHRoaXMudmlzaWJsZSAtIDEpIC8gMlxcclxcbiAgICAgICAgICAgICAgICBuID0gKHRoaXMuYmlhcy50b0xvd2VyQ2FzZSgpID09PSAnbGVmdCcgPyBNYXRoLmNlaWwobikgOiBNYXRoLmZsb29yKG4pKVxcclxcbiAgICAgICAgICAgICAgICBuKytcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyID09PSAnbHRyJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodGhpcy50b3RhbCAtIHRoaXMuY3VycmVudEluZGV4IC0gbikgPD0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgtcGFyc2VJbnQodGhpcy50b3RhbCAtIHRoaXMuY3VycmVudEluZGV4IC0gbikpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5jdXJyZW50SW5kZXggKyBuKVxcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRJbmRleCAtIG4pXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIHJpZ2h0T3V0SW5kZXggKCkge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICh0aGlzLnZpc2libGUgLSAxKSAvIDJcXHJcXG4gICAgICAgICAgICAgICAgbiA9ICh0aGlzLmJpYXMudG9Mb3dlckNhc2UoKSA9PT0gJ3JpZ2h0JyA/IE1hdGguY2VpbChuKSA6IE1hdGguZmxvb3IobikpXFxyXFxuICAgICAgICAgICAgICAgIG4rK1xcclxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXIgPT09ICdsdHInKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY3VycmVudEluZGV4IC0gbilcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMudG90YWwgLSB0aGlzLmN1cnJlbnRJbmRleCAtIG4pIDw9IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoLXBhcnNlSW50KHRoaXMudG90YWwgLSB0aGlzLmN1cnJlbnRJbmRleCAtIG4sIDEwKSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmN1cnJlbnRJbmRleCArIG4pXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbWV0aG9kczoge1xcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIEdvIHRvIG5leHQgc2xpZGVcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBnb05leHQgKCkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc05leHRQb3NzaWJsZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0xhc3RTbGlkZSA/IHRoaXMuZ29TbGlkZSgwKSA6IHRoaXMuZ29TbGlkZSh0aGlzLmN1cnJlbnRJbmRleCArIDEpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIEdvIHRvIHByZXZpb3VzIHNsaWRlXFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgZ29QcmV2ICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmV2UG9zc2libGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNGaXJzdFNsaWRlID8gdGhpcy5nb1NsaWRlKHRoaXMudG90YWwgLSAxKSA6IHRoaXMuZ29TbGlkZSh0aGlzLmN1cnJlbnRJbmRleCAtIDEpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIEdvIHRvIHNsaWRlXFxyXFxuICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBpbmRleCBvZiBzbGlkZSB3aGVyZSB0byBnb1xcclxcbiAgICAgICAgICAgICAqL1xcclxcbiAgICAgICAgICAgIGdvU2xpZGUgKGluZGV4KSB7XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMudG90YWwgLSAxKSA/IDAgOiBpbmRleFxcclxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2sgPSB0cnVlXFxyXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFNsaWRlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkxhc3RTbGlkZSAhPT0gbm9vcCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignb25MYXN0U2xpZGUgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBAbGFzdC1zbGlkZScpXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGFzdFNsaWRlKHRoaXMuY3VycmVudEluZGV4KVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnbGFzdC1zbGlkZScsIHRoaXMuY3VycmVudEluZGV4KVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZS1zbGlkZS1jaGFuZ2UnLCB0aGlzLmN1cnJlbnRJbmRleClcXHJcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmFuaW1hdGlvbkVuZCgpLCB0aGlzLmFuaW1hdGlvblNwZWVkKVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgLyoqXFxyXFxuICAgICAgICAgICAgICogR28gdG8gc2xpZGUgZmFyIHNsaWRlXFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgZ29GYXIgKGluZGV4KSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gKGluZGV4ID09PSB0aGlzLnRvdGFsIC0gMSAmJiB0aGlzLmlzRmlyc3RTbGlkZSkgPyAtMSA6IChpbmRleCAtIHRoaXMuY3VycmVudEluZGV4KVxcclxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xhc3RTbGlkZSAmJiBpbmRleCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IDFcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmMiA9IChkaWZmIDwgMCkgPyAtZGlmZiA6IGRpZmZcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHRpbWVCdWZmID0gMFxcclxcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDBcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBkaWZmMikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxXFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKGRpZmYyID09PSAxKSA/IDAgOiAodGltZUJ1ZmYpXFxyXFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IChkaWZmIDwgMCkgPyB0aGlzLmdvUHJldihkaWZmMikgOiB0aGlzLmdvTmV4dChkaWZmMiksIHRpbWVvdXQpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aW1lQnVmZiArPSAodGhpcy5hbmltYXRpb25TcGVlZCAvIChkaWZmMikpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIFRyaWdnZXIgYWN0aW9ucyB3aGVuIGFuaW1hdGlvbiBlbmRzXFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uRW5kICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NrID0gZmFsc2VcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25TbGlkZUNoYW5nZSAhPT0gbm9vcCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdvblNsaWRlQ2hhbmdlIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQGFmdGVyLXNsaWRlLWNoYW5nZScpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5vblNsaWRlQ2hhbmdlKHRoaXMuY3VycmVudEluZGV4KVxcclxcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdhZnRlci1zbGlkZS1jaGFuZ2UnLCB0aGlzLmN1cnJlbnRJbmRleClcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIFRyaWdnZXIgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkXFxyXFxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBoYW5kbGVNb3VzZXVwICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZWRvd24gPSBmYWxzZVxcclxcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQgPSAwXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAvKipcXHJcXG4gICAgICAgICAgICAgKiBUcmlnZ2VyIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBwcmVzc2VkXFxyXFxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBoYW5kbGVNb3VzZWRvd24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKCFlLnRvdWNoZXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZVxcclxcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydFggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAvKipcXHJcXG4gICAgICAgICAgICAgKiBUcmlnZ2VyIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBwcmVzc2VkIGFuZCB0aGVuIG1vdmVkIChtb3VzZSBkcmFnKVxcclxcbiAgICAgICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0XFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgaGFuZGxlTW91c2Vtb3ZlIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50UG9zWCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFhcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gKHRoaXMuZHJhZ1N0YXJ0WCAtIGV2ZW50UG9zWClcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID0gZGVsdGFYXFxyXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdPZmZzZXQgPiB0aGlzLm1pblN3aXBlRGlzdGFuY2UpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2V1cCgpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvTmV4dCgpXFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnT2Zmc2V0IDwgLXRoaXMubWluU3dpcGVEaXN0YW5jZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZXVwKClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29QcmV2KClcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgLyoqXFxyXFxuICAgICAgICAgICAgICogQSBtdXRhdGlvbiBvYnNlcnZlciBpcyB1c2VkIHRvIGRldGVjdCBjaGFuZ2VzIHRvIHRoZSBjb250YWluaW5nIG5vZGVcXHJcXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byBrZWVwIHRoZSBtYWduZXQgY29udGFpbmVyIGluIHN5bmMgd2l0aCB0aGUgaGVpZ2h0IGl0cyByZWZlcmVuY2Ugbm9kZS5cXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBhdHRhY2hNdXRhdGlvbk9ic2VydmVyICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fFxcclxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXJcXHJcXG4gICAgICAgICAgICAgICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRhKClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRlbCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLCBjb25maWcpXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIFN0b3AgbGlzdGVuaW5nIHRvIG11dGF0aW9uIGNoYW5nZXNcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBkZXRhY2hNdXRhdGlvbk9ic2VydmVyICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXV0YXRpb25PYnNlcnZlcikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAvKipcXHJcXG4gICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBzbGlkZXNcXHJcXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBzbGlkZXNcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBnZXRTbGlkZUNvdW50ICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNsb3RzLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzLmRlZmF1bHQuZmlsdGVyKCh2YWx1ZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50YWcgIT09IHZvaWQgMFxcclxcbiAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBzbGlkZSB3aXRoIGFuZCBrZWVwIGRlZmluZWQgYXNwZWN0IHJhdGlvXFxyXFxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBBc3BlY3QgcmF0aW8gbnVtYmVyXFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgY2FsY3VsYXRlQXNwZWN0UmF0aW8gKHdpZHRoLCBoZWlnaHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gaGVpZ2h0KVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgLyoqXFxyXFxuICAgICAgICAgICAgICogUmUtY29tcHV0ZSB0aGUgbnVtYmVyIG9mIHNsaWRlcyBhbmQgY3VycmVudCBzbGlkZVxcclxcbiAgICAgICAgICAgICAqL1xcclxcbiAgICAgICAgICAgIGNvbXB1dGVEYXRhICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbCA9IHRoaXMuZ2V0U2xpZGVDb3VudCgpXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gcGFyc2VJbnQodGhpcy5zdGFydEluZGV4KSA+IHRoaXMudG90YWwgLSAxID8gdGhpcy50b3RhbCAtIDEgOiBwYXJzZUludCh0aGlzLnN0YXJ0SW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLiRlbC5jbGllbnRXaWR0aFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgc2V0U2l6ZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuJGVsLnN0eWxlLmNzc1RleHQgKz0gJ2hlaWdodDonICsgdGhpcy5zbGlkZUhlaWdodCArICdweDsnXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNoaWxkTm9kZXNbMF0uc3R5bGUuY3NzVGV4dCArPSAnd2lkdGg6JyArIHRoaXMuc2xpZGVXaWR0aCArICdweDsnICsgJyBoZWlnaHQ6JyArIHRoaXMuc2xpZGVIZWlnaHQgKyAncHg7J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb3VudGVkICgpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRhKClcXHJcXG4gICAgICAgICAgICB0aGlzLmF0dGFjaE11dGF0aW9uT2JzZXJ2ZXIoKVxcclxcbiAgICAgICAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIpIHtcXHJcXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc2V0U2l6ZSlcXHJcXG4gICAgICAgICAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW91c2Vkb3duKVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNldXApXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlbW92ZSlcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2V1cClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2Vtb3ZlKVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJlZm9yZURlc3Ryb3kgKCkge1xcclxcbiAgICAgICAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hNdXRhdGlvbk9ic2VydmVyKClcXHJcXG4gICAgICAgICAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZW1vdmUpXFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlbW92ZSlcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5zZXRTaXplKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbjwvc2NyaXB0PlxcclxcblxcclxcbjxzdHlsZSBzY29wZWQ+XFxyXFxuICAgIC5jYXJvdXNlbC0zZC1jb250YWluZXIge1xcclxcbiAgICAgICAgbWluLWhlaWdodDogMXB4O1xcclxcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgICAgICB6LWluZGV4OiAwO1xcclxcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgICAgIG1hcmdpbjogMjBweCBhdXRvO1xcclxcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgfVxcclxcbiAgICAuY2Fyb3VzZWwtM2Qtc2xpZGVyIHtcXHJcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xcclxcbiAgICAgICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXHJcXG4gICAgICAgIC13ZWJraXQtcGVyc3BlY3RpdmU6IDEwMDBweDtcXHJcXG4gICAgICAgIC1tb3otcGVyc3BlY3RpdmU6IDEwMDBweDtcXHJcXG4gICAgICAgIHBlcnNwZWN0aXZlOiAxMDAwcHg7XFxyXFxuICAgIH1cXHJcXG48L3N0eWxlPlwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yZjE3YzQxYlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2RlbW8vY2Fyb3VzZWwudnVlXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGF1dG9wbGF5ID0ge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGFnIHRvIGVuYWJsZSBhdXRvcGxheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGF1dG9wbGF5OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaW1lIGVsYXBzZWQgYmVmb3JlIG5leHQgc2xpZGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBhdXRvcGxheVRpbWVvdXQ6IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAyMDAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGFnIHRvIHBhdXNlIGF1dG9wbGF5IG9uIGhvdmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF0YSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkZXN0cm95ZWQgKCkge1xyXG4gICAgICAgIHRoaXMucGF1c2VBdXRvcGxheSgpXHJcblxyXG4gICAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMucGF1c2VBdXRvcGxheSlcclxuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuc3RhcnRBdXRvcGxheSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHBhdXNlQXV0b3BsYXkgKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvcGxheUludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9wbGF5SW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHRoaXMuYXV0b3BsYXlJbnRlcnZhbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhcnRBdXRvcGxheSAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9wbGF5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPT09ICdsdHInID8gdGhpcy5nb1ByZXYoKSA6IHRoaXMuZ29OZXh0KClcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuYXV0b3BsYXlUaW1lb3V0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIgJiYgdGhpcy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMucGF1c2VBdXRvcGxheSlcclxuICAgICAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuc3RhcnRBdXRvcGxheSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRBdXRvcGxheSgpXHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4kZWwpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGF1dG9wbGF5XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZGVtby9taXhpbnMvYXV0b3BsYXkuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYmNhYTBhZjRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9zbGlkZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcImQwMzJjZWRhXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWJjYWEwYWY0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vc2xpZGUudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWJjYWEwYWY0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vc2xpZGUudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWJjYWEwYWY0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2RlbW8vc2xpZGUudnVlXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmNhcm91c2VsLTNkLXNsaWRlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRvcDogMDtcXG4gICAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgICBib3JkZXItY29sb3I6ICMwMDA7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uY2Fyb3VzZWwtM2Qtc2xpZGUge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4uY2Fyb3VzZWwtM2Qtc2xpZGUgaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcbi5jYXJvdXNlbC0zZC1zbGlkZS5jdXJyZW50IHtcXG4gICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxuICAgIHRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9BZG1pbmlzdHJhdG9yL0RvY3VtZW50cy9HaXRIdWIvdnVlLXNsaWRlLXNob3cvZGVtby9kZW1vL3NsaWRlLnZ1ZT81MmE2OTM0OFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBa0dBO0lBQ0EsbUJBQUE7SUFDQSxXQUFBO0lBQ0EsbUJBQUE7SUFDQSxpQkFBQTtJQUNBLE9BQUE7SUFDQSxtQkFBQTtJQUNBLG1CQUFBO0lBQ0EsaUNBQUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0EsdUJBQUE7SUFDQSxlQUFBO0lBQ0EsVUFBQTtJQUNBLHVCQUFBO0NBQ0E7QUFDQTtJQUNBLGlCQUFBO0NBQ0E7QUFDQTtJQUNBLFlBQUE7Q0FDQTtBQUNBO0lBQ0Esc0JBQUE7SUFDQSwrQkFBQTtJQUNBLDJCQUFBO0lBQ0EsYUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJzbGlkZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgICA8ZGl2IFxcclxcbiAgICBjbGFzcz1cXFwiY2Fyb3VzZWwtM2Qtc2xpZGVcXFwiIFxcclxcbiAgICA6c3R5bGU9XFxcInNsaWRlU3R5bGVcXFwiIFxcclxcbiAgICA6Y2xhc3M9XFxcInsgJ2N1cnJlbnQnOiBpc0N1cnJlbnQgfVxcXCIgXFxyXFxuICAgIEBjbGljaz1cXFwiZ29UbygpXFxcIj5cXHJcXG4gICAgICAgIDxzbG90Pjwvc2xvdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbiAgICBleHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgICAgICBuYW1lOiAnc2xpZGUnLFxcclxcbiAgICAgICAgcHJvcHM6IHtcXHJcXG4gICAgICAgICAgICBpbmRleDoge1xcclxcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXJcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZGF0YSAoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLiRwYXJlbnQsXFxyXFxuICAgICAgICAgICAgICAgIHN0eWxlczoge30sXFxyXFxuICAgICAgICAgICAgICAgIHpJbmRleDogOTk5XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAgICAgaXNDdXJyZW50ICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT09IHRoaXMucGFyZW50LmN1cnJlbnRJbmRleFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgc2xpZGVTdHlsZSAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBzdHlsZXMgPSB7fVxcclxcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBySW5kZXggPSB0aGlzLmdldFNpZGVJbmRleCh0aGlzLnBhcmVudC5yaWdodEluZGljZXMpXFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsSW5kZXggPSB0aGlzLmdldFNpZGVJbmRleCh0aGlzLnBhcmVudC5sZWZ0SW5kaWNlcylcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChySW5kZXggPj0gMCB8fCBsSW5kZXggPj0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHJJbmRleCA+PSAwID8gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbihySW5kZXgsIHRydWUsIHRoaXMuekluZGV4KSA6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb24obEluZGV4LCBmYWxzZSwgdGhpcy56SW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSAxXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5oYXNIaWRkZW5TbGlkZXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEluZGV4KHRoaXMucGFyZW50LmxlZnRPdXRJbmRleCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbih0aGlzLnBhcmVudC5sZWZ0SW5kaWNlcy5sZW5ndGggLSAxLCBmYWxzZSwgdGhpcy56SW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoSW5kZXgodGhpcy5wYXJlbnQucmlnaHRPdXRJbmRleCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbih0aGlzLnBhcmVudC5yaWdodEluZGljZXMubGVuZ3RoIC0gMSwgdHJ1ZSwgdGhpcy56SW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN0eWxlcywge1xcclxcbiAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci13aWR0aCc6IHRoaXMucGFyZW50LmJvcmRlciArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiB0aGlzLnBhcmVudC5zbGlkZVdpZHRoICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiB0aGlzLnBhcmVudC5zbGlkZUhlaWdodCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICAndHJhbnNpdGlvbic6ICcgdHJhbnNmb3JtICcgKyB0aGlzLnBhcmVudC5hbmltYXRpb25TcGVlZCArICdtcywgJyArXFxyXFxuICAgICAgICAgICAgICAgICAgICAnICAgICAgICAgICAgICAgb3BhY2l0eSAnICsgdGhpcy5wYXJlbnQuYW5pbWF0aW9uU3BlZWQgKyAnbXMsICcgK1xcclxcbiAgICAgICAgICAgICAgICAgICAgJyAgICAgICAgICAgICAgIHZpc2liaWxpdHkgJyArIHRoaXMucGFyZW50LmFuaW1hdGlvblNwZWVkICsgJ21zJ1xcclxcbiAgICAgICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICAgICAgZ2V0U2lkZUluZGV4IChhcnJheSkge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAtMVxcclxcbiAgICAgICAgICAgICAgICBhcnJheS5mb3JFYWNoKChwb3MsIGkpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoSW5kZXgocG9zKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIG1hdGNoSW5kZXggKGluZGV4KSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPj0gMCkgPyB0aGlzLmluZGV4ID09PSBpbmRleCA6ICh0aGlzLnBhcmVudC50b3RhbCArIGluZGV4KSA9PT0gdGhpcy5pbmRleFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gKGksIHBvc2l0aXZlLCB6SW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgeiA9ICF0aGlzLnBhcmVudC5kaXNhYmxlM2QgPyBwYXJzZUludCh0aGlzLnBhcmVudC5pbnZlcnNlU2NhbGluZykgKyAoKGkgKyAxKSAqIDEwMCkgOiAwXFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAhdGhpcy5wYXJlbnQuZGlzYWJsZTNkID8gcGFyc2VJbnQodGhpcy5wYXJlbnQucGVyc3BlY3RpdmUpIDogMFxcclxcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVtYWluID0gKHRoaXMucGFyZW50LnNwYWNlID09PSAnYXV0bycpXFxyXFxuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KChpICsgMSkgKiAodGhpcy5wYXJlbnQud2lkdGggLyAxLjUpLCAxMClcXHJcXG4gICAgICAgICAgICAgICAgICAgIDogcGFyc2VJbnQoKGkgKyAxKSAqICh0aGlzLnBhcmVudC5zcGFjZSksIDEwKVxcclxcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSAocG9zaXRpdmUpXFxyXFxuICAgICAgICAgICAgICAgICAgICA/ICd0cmFuc2xhdGVYKCcgKyAobGVmdFJlbWFpbikgKyAncHgpIHRyYW5zbGF0ZVooLScgKyB6ICsgJ3B4KSAnICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICdyb3RhdGVZKC0nICsgeSArICdkZWcpJ1xcclxcbiAgICAgICAgICAgICAgICAgICAgOiAndHJhbnNsYXRlWCgtJyArIChsZWZ0UmVtYWluKSArICdweCkgdHJhbnNsYXRlWigtJyArIHogKyAncHgpICcgK1xcclxcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0ZVkoJyArIHkgKyAnZGVnKSdcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wYXJlbnQuc3BhY2UgPT09ICdhdXRvJyA/IDAgOiBwYXJzZUludCgoaSArIDEpICogKHRoaXMucGFyZW50LnNwYWNlKSlcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxcclxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyB6SW5kZXg6IHpJbmRleCAtIChNYXRoLmFicyhpKSArIDEpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGdvVG8gKCkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuY2xpY2thYmxlID09PSB0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5nb0Zhcih0aGlzLmluZGV4KVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuPC9zY3JpcHQ+XFxyXFxuXFxyXFxuPHN0eWxlPlxcclxcbiAgICAuY2Fyb3VzZWwtM2Qtc2xpZGUge1xcclxcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICAgICAgb3BhY2l0eTogMDtcXHJcXG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgICAgICB0b3A6IDA7XFxyXFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxcHg7XFxyXFxuICAgICAgICBib3JkZXItY29sb3I6ICMwMDA7XFxyXFxuICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcXHJcXG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcXHJcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICAgICAgbWFyZ2luOiAwO1xcclxcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgfVxcclxcbiAgICAuY2Fyb3VzZWwtM2Qtc2xpZGUge1xcclxcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG4gICAgfVxcclxcbiAgICAuY2Fyb3VzZWwtM2Qtc2xpZGUgaW1nIHtcXHJcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICB9XFxyXFxuICAgIC5jYXJvdXNlbC0zZC1zbGlkZS5jdXJyZW50IHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcXHJcXG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAgICAgei1pbmRleDogOTk5O1xcclxcbiAgICB9XFxyXFxuPC9zdHlsZT5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYmNhYTBhZjRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vZGVtby9zbGlkZS52dWVcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJjYXJvdXNlbC0zZC1zbGlkZVwiLFxuICAgICAgY2xhc3M6IHsgY3VycmVudDogX3ZtLmlzQ3VycmVudCB9LFxuICAgICAgc3R5bGU6IF92bS5zbGlkZVN0eWxlLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS5nb1RvKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYmNhYTBhZjRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1iY2FhMGFmNFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9kZW1vL3NsaWRlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImNhcm91c2VsLTNkLWNvbnRhaW5lclwiLFxuICAgICAgc3R5bGU6IHsgaGVpZ2h0OiB0aGlzLnNsaWRlSGVpZ2h0ICsgXCJweFwiIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwiY2Fyb3VzZWwtM2Qtc2xpZGVyXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnNsaWRlV2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc2xpZGVIZWlnaHQgKyBcInB4XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMmYxN2M0MWJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yZjE3YzQxYlwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL2RlbW8vY2Fyb3VzZWwudnVlXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9